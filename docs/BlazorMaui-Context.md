Blazor Hybrid (MAUI) Application Behavior – Architecture, Lifecycle, and Integration
BlazorWebView Architecture in .NET MAUI (Blazor Hybrid)
In PTDoc’s .NET MAUI client, Blazor is integrated via the BlazorWebView control, creating a hybrid application. This means Razor components run natively on the device within the MAUI app’s .NET process, and render their output to an embedded Web View UI element
. Unlike Blazor WebAssembly (WASM) or Server, components in a BlazorWebView do not run in a browser sandbox or require WebAssembly at all – they execute on the normal .NET runtime (with full access to the device’s capabilities) and communicate with the WebView through a local interop channel
. The Blazor UI is essentially hosted inside a WebView, but all UI updates are driven by .NET code. In practice, this hybrid setup behaves much like client-side Blazor in terms of UI logic, just hosted in a native app instead of a standalone browser tab. How it’s set up: A MAUI Blazor app typically includes a wwwroot/index.html (the Blazor host page) and uses BlazorWebView on a XAML page to load it. For example, the MAUI MainPage.xaml might contain:
<BlazorWebView HostPage="wwwroot/index.html">
    <BlazorWebView.RootComponents>
        <RootComponent Selector="#app" ComponentType="{x:Type local:Main}" />
    </BlazorWebView.RootComponents>
</BlazorWebView>
This XAML (from the default template) points the BlazorWebView to the Blazor app’s host page and identifies the root Razor component to load (e.g. Main.razor) and where to render it in the DOM (Selector="#app" matches an element in index.html)
. Under the hood, the BlazorWebView will load the HTML from the app’s resources and initialize the Blazor runtime. In the MAUI startup (MauiProgram.cs), you must register Blazor services by calling builder.Services.AddMauiBlazorWebView(); (and usually enable debugging helpers in development via builder.Services.AddBlazorWebViewDeveloperTools();)
. Once configured, the MAUI app and Blazor share the same dependency injection (DI) container, allowing services and data to be easily shared across the native and web portions of the app. Browser Engine Differences: Because rendering is done in a WebView, the exact web engine varies by platform. For example, MAUI uses WebView2 (Edge Chromium) on Windows, Chromium WebView on Android, and WKWebView (Safari) on iOS/Mac
. This means that some HTML/CSS or JavaScript might behave slightly differently on each platform. Platform-specific web APIs may only be available on certain engines, and styling can differ. Always test UI on all target platforms to catch any inconsistencies
. Also note that on Windows, end users must have the WebView2 runtime installed for BlazorWebView to function
 (the developer template usually displays a notice or handles this).
Component Lifecycle in a MAUI Blazor Hybrid App
Blazor components in a BlazorWebView follow the same lifecycle conventions as in standard Blazor (since the Blazor framework running inside the WebView is essentially the same as Blazor WASM/Server). Each component goes through initialization (OnInitialized{Async}), parameter setting (OnParametersSet{Async} on each render), rendering, and after-render events (OnAfterRender{Async}) just as it would on the web. There is no server prerendering phase in a typical MAUI Blazor app, so you don’t have the split between a static prerender and interactive render as in Blazor Server. This means that OnAfterRenderAsync(firstRender:true) will run exactly once on the first render when the WebView has fully loaded the component, so you can safely put JavaScript initialization calls there without worrying about a non-interactive prerender pass. (In contrast, on Blazor Server prerendering, OnAfterRender is delayed until the client connects – not an issue for Blazor Hybrid, since it’s all local.) Essentially, the Blazor rendering flow – diffing the UI tree and only re-rendering on state change – works the same within BlazorWebView. However, it’s important to avoid heavy work on the UI thread during lifecycle events, especially on mobile devices. Just as in web or server Blazor, long synchronous operations in lifecycle methods (e.g. doing a big computation in OnInitialized) will block the UI from rendering. In a MAUI hybrid app, that can lead to visible delays or even the OS feeling the app is unresponsive. Always prefer asynchronous loading patterns: do minimal setup synchronously, then use await for longer tasks so the UI thread can render interim feedback. For example, start an API call in OnInitializedAsync, let the component render a placeholder UI (spinner, “Loading…” text, etc.), and then update the UI when the data arrives. This ensures the user sees something quickly, even if final data takes time – a known pitfall is leaving the screen blank while waiting for data, which is especially noticeable on app startup or slow networks. First Render and OnAfterRender: On the first render of a component, Blazor will invoke OnAfterRenderAsync(true) after the HTML is rendered to the WebView’s DOM. Use the firstRender flag to run one-time setup code here, such as initializing JS libraries or performing DOM manipulation that requires the element to be present. Subsequent renders will call OnAfterRenderAsync(false) and you typically should not repeat the initialization logic in those calls (to avoid duplicates). This pattern is the same as in web Blazor, but it’s worth emphasizing for hybrid apps because if a component doesn’t appear or update in the MAUI app, it could be that its JS initialization never ran. Always check that you placed any JS interop calls in the proper lifecycle hook with the appropriate guards. As a rule: Do not call JavaScript-dependent code during component initialization or before the WebView is ready. Instead, use OnAfterRenderAsync and conditional logic (if (firstRender)) so that such code runs only when the DOM is interactive. (This guidance was highlighted for server-side prerendering and MAUI scenarios because calling JS too early can fail – in MAUI’s case the WebView must be loaded.) Another note: StateHasChanged and Rendering – The Blazor rendering cycle inside MAUI will coalesce rapid state changes just like in other Blazor hosts. You generally should not call StateHasChanged() manually unless you’re updating state from an external callback (timer, etc.). Excessive calls can hurt performance. The BlazorWebView ensures that UI updates happen on the correct thread; if you do trigger UI changes from background threads, use InvokeAsync or similar patterns to marshal to the Blazor UI thread (just as you would in a normal Blazor app to avoid thread errors). The bottom line is that lifecycle best practices from Blazor (avoid long blocking code, use async, minimal StateHasChanged usage) all apply equally in the hybrid context.
Native and Blazor Integration Patterns (Communication Across the Divide)
One of the powerful features of Blazor Hybrid is that your Blazor components and native MAUI code can interact and share data, but this requires explicit bridges – the Blazor UI is essentially running in an isolated WebView, so it cannot directly reference MAUI UI elements, and vice versa. Agents must be mindful that you cannot simply place MAUI XAML controls inside a Blazor .razor file, nor call Blazor component methods directly from MAUI code without a mechanism. Below we outline common integration approaches:
Mixing Native and Blazor UI: If you need to show native MAUI controls (say a Camera preview or a platform-specific picker) alongside Blazor content, the approach is to compose them in the MAUI XAML layout, not to embed one into the other. For example, you might create a MAUI ContentPage that has a Grid with a BlazorWebView in one row and a native control (or overlay) in another row or on top. You can toggle the native control’s visibility or position it absolute over the BlazorWebView when needed. Do not attempt to directly add a MAUI control in the Razor component markup – that won’t work, as the Razor markup only knows how to render HTML/Blazor components inside the WebView
. Instead, have the MAUI page own the layout and show/hide native elements in response to events (for instance, a Blazor button could trigger showing a native modal or overlay through an event, as discussed next).
Blazor-to-Native Calls (invoking platform features): The recommended pattern is to use dependency injection and an intermediary service to funnel calls or data between Blazor and native code
. For example, you can create a singleton service (say, IDeviceService) that is added to the DI container in MauiProgram. This service can expose methods and events for various actions. In a Razor component, you inject this DeviceService and call a method (e.g. DeviceService.TriggerCameraCapture()), which internally fires an event. On the native side (in the MAUI page or wherever appropriate), you have access to the same singleton service (since MAUI and Blazor share the IServiceProvider). The native code can subscribe to the event (or check a property) and when it sees the “TriggerCameraCapture” event, it invokes the actual platform-specific API (such as launching the camera or opening a native view). This way, the Blazor component remains unaware of platform details – it just calls a service method – and the native layer handles it, or vice versa. By injecting a common service into both Blazor and MAUI, you create a bridge for method calls and data flow
. For instance:
// In MauiProgram.cs
builder.Services.AddSingleton<DeviceBridge>();  // a service for bridging calls

// A simple bridge service
public class DeviceBridge {
    // e.g., event for a native action
    public event EventHandler? OnCaptureRequested; 

    public void RequestCapture() {
        OnCaptureRequested?.Invoke(this, EventArgs.Empty);
    }

    // possibly a callback from native to Blazor via event as well
    public event EventHandler<string>? OnDataReceived;
    public void RaiseDataReceived(string data) {
        OnDataReceived?.Invoke(this, data);
    }
}
In a Razor component you might use this service as:
@inject DeviceBridge Bridge

<button @onclick="@(()=> Bridge.RequestCapture())">Take Photo</button>
And in the MAUI page code-behind:
// Retrieve the same singleton service instance
var bridge = this.Handler.MauiContext.Services.GetService<DeviceBridge>();
if(bridge != null) {
    bridge.OnCaptureRequested += async (s,e) => {
        // Code to open camera and capture photo, then:
        string photoPath = await CapturePhotoAsync();
        bridge.RaiseDataReceived(photoPath);
    };
}
Here the Blazor UI triggers RequestCapture(), the native side listens and opens the camera, then returns the result via RaiseDataReceived, which the Blazor side could also listen to (e.g., the Razor component could subscribe to Bridge.OnDataReceived to get the photo path). This pattern cleanly separates concerns and works cross-platform.
Native-to-Blazor Calls: The above covers Blazor initiating an action. If a native MAUI element (like a hardware back button or a native menu) needs to cause something in the Blazor UI, you also use the DI bridge idea but in reverse: call a method on the service from the native side, and have the Blazor component subscribe to an event or poll a property. Another approach provided by the framework is BlazorWebView.TryDispatchAsync, which allows native code to run a callback within the Blazor renderer’s synchronization context
. For example, suppose you have a native MAUI Button and you want it to navigate the Blazor WebView to a different page. You can do:
// Assuming _blazorWebView is your BlazorWebView instance on the page
await _blazorWebView.TryDispatchAsync(sp => {
    var navManager = sp.GetRequiredService<NavigationManager>();
    navManager.NavigateTo("some/blazor/page");
});
This will safely obtain the Blazor NavigationManager from the Blazor WebView’s service provider and call it to navigate within the Blazor routing context
. TryDispatchAsync is powerful for accessing any scoped services or functionality from outside. Use it whenever you need to interact with Blazor-only services (like NavigationManager or JSRuntime) as a result of a native UI event.
JavaScript Interop vs. Direct .NET Calls: In a purely web Blazor app, one might use JavaScript Interop to call into native device features (for example, using JavaScript to invoke a mobile capability via a Cordova-like plugin or Web API). In a Blazor Hybrid app, you have the full .NET API surface available directly, so you usually don’t need JS Interop to call device APIs – you’d call them in .NET via MAUI libraries or dependency injection. JS interop is still available (and we discuss specifics in the next section), but consider whether a direct .NET approach is cleaner. For instance, to get geolocation in a hybrid app, you could just use Xamarin/MAUI Essentials Geolocation.GetLastKnownLocationAsync() in a service, rather than injecting JS to call navigator.geolocation. The hybrid model lets you leverage native code where possible, using Blazor mainly for UI.
No Shared UI State by Default: Keep in mind that each BlazorWebView has its own isolated rendering context and (by default) a separate DI scope for scoped services. Singletons are shared app-wide (including between MAUI and Blazor), but scoped services are tied to a particular BlazorWebView instance. If your app only has one BlazorWebView (common case), you can treat scoped services as effectively single-instance for that running app. But if you ever had multiple BlazorWebView controls (for example, two different pages each hosting some Blazor content), each would get its own copy of scoped services. Plan accordingly for where to store shared state: truly global state can use singletons or static singletons (since in MAUI there’s one user), but per-page or per-component state might belong in scoped or cascading parameters. MAUI’s Blazor integration also provides ways for the native side to access a Blazor component’s scoped service provider if needed (as shown with TryDispatchAsync).
In summary, agents must explicitly design the communication pathways between Blazor and the native part of the app. The DI bridge approach is usually the safest and most testable way to coordinate actions (since it keeps a clean separation of concerns and uses strongly-typed .NET calls). Avoid hacks like invoking JavaScript to manipulate XAML UI or vice versa – always prefer a .NET interop (through services/events or TryDispatchAsync) or a clearly defined JS-call if absolutely needed.
JavaScript Interop in Blazor Hybrid Apps
Blazor’s standard JavaScript Interop (IJSRuntime) works in a hybrid app, but there are some nuances:
JS Runtime Environment: In BlazorWebView, the JavaScript executes inside the embedded WebView’s context (e.g., the WebView2 or WKWebView JavaScript engine). Calls you make with IJSRuntime.InvokeAsync from .NET will be dispatched to that WebView’s JavaScript runtime, just like in a web app. The difference is that the .NET code is running natively, so behind the scenes the interop call goes over a native->web boundary (likely via a local IPC channel between .NET and the WebView). This is usually seamless – you can await jsRuntime.InvokeAsync<string>("myFunc", arg1) and it will return a result as expected. Performance of interop is generally fast on modern devices, but not as fast as an in-process method call, so still treat it as an asynchronous, potentially UI-blocking operation. Avoid very frequent JS calls in tight loops; batch work if you can, or do more logic on one side to reduce chatty calls.
Including Scripts and Libraries: In a hybrid app, there is no network fetch of scripts by default (unless your Blazor app explicitly fetches CDN resources). Typically, any JS libraries your components need (for example, a charting library) should be added to your wwwroot/index.html or served as static files in the wwwroot folder, similar to a Blazor WASM app. Since the MAUI Blazor app uses a local HTML file, you need to ensure all references are either to local files or to accessible web URLs. If your Blazor WASM app relied on an external script (CDN), consider bundling it for offline use in the hybrid app, or at least be aware that the app will need internet to fetch it. Also remember to add any CSS files your components need into the app. If a component uses certain CSS (e.g., from a library or an icon font), make sure the MAUI host includes those static assets; otherwise the component might appear broken on the native app.
Limitations of the WebView Sandbox: The WebView running your Blazor UI is similar to a full browser, but on some platforms it may be a sandboxed environment. Certain browser APIs might be restricted or not available. For example, things like window.alert or window.open may behave differently on mobile – window.alert might not show any dialog on some platforms (or show a native alert that could disrupt the user experience). Another example: file access in the browser context (like using JavaScript to read local files) won’t magically grant access to the device’s file system beyond the WebView’s sandbox. In general, assume the JS environment is constrained – if you need functionality outside of pure web capabilities, use .NET to accomplish it. The BlazorWebView environment also doesn’t have a traditional browser address bar or dev console visible to the user, so debugging might require attaching external dev tools (see Debugging section below).
Invoking .NET from JavaScript: Blazor supports calling static .NET methods from JS via [JSInvokable]. In hybrid, this works too, but note that since .NET is not running in a browser thread, the performance is similar to any interop. If you have some JavaScript that needs to call back into .NET (perhaps to notify of something), you can still use DotNet.invokeMethodAsync or pass a .NET Object Ref to JS and call methods on it. This can be useful for libraries that expect to callback into .NET (for instance, registering a JS event that triggers a .NET handler). Just be mindful of threading – Blazor will ensure the calls get to the right context.
Use Case – JS for UI Libraries: One common use is embedding a JS UI library (like charts or maps) in a Blazor component. In a hybrid app, you do the same as usual: include the JS and CSS, and initialize the library in OnAfterRenderAsync(firstRender). If something isn’t showing up, double-check that:
The script is actually loaded (open developer tools to see if there are 404 errors or similar).
You only call the JS after the element is in the DOM (hence the OnAfterRender(firstRender) pattern).
If using Blazor Server or other modes as well, guard the call (e.g., don’t run on prerender – not applicable to pure MAUI, but relevant if code is shared with server mode).
In MAUI, ensure any special web security settings are handled if needed (e.g., WKWebView might block insecure content; if loading any http resources on iOS, you might need to configure App Transport Security or use https).
In summary, JavaScript interop in MAUI Blazor is a powerful tool but often optional – use it for what it’s good at (web UI manipulations, calling existing JS libs) but use .NET for anything platform-native. And always test those interop pieces on actual devices; an API that works in a desktop WebView might behave differently on iOS WebKit.
State Management and Persistence in Blazor Hybrid
Managing state in a Blazor Hybrid app shares many similarities with Blazor WebAssembly, with a few key differences in scope and lifetime:
Per-User State: In a Blazor WebAssembly or MAUI app, there is only one user/context, so using a static or singleton to hold app-wide state (like a global settings object, or cached data) is acceptable and will not cross user boundaries. In Blazor Server, that would be dangerous (because it’s multi-user), but in a MAUI app each app instance is a single user environment. Thus, PTDoc’s hybrid app can use singletons or static singletons for things like a selected patient ID, without risk of leaking data between users (there’s no server-side shared memory concern). That said, if the project ever introduces multi-user (or multiple windows), we’d revisit this. For now, agents can treat the Blazor portion as single-user and simplify state management accordingly (no circuit handling needed, etc.).
Scoped vs. Singleton Services: As noted, services registered as Scoped in a BlazorWebView are tied to the lifetime of the BlazorWebView’s navigation context. In most cases, the Blazor content lives for the duration of the page, possibly the entire app session (unless you remove and re-add the BlazorWebView). For practical purposes, many apps just use Singleton services for most data or state so that it persists as long as the app runs (because mobile apps can be suspended or resumed, but if not fully killed, the singleton remains in memory). Use Scoped if you specifically want a fresh instance of a service for the Blazor UI each time it’s created or reset, but note that if your MAUI app never disposes the BlazorWebView, the scope might effectively be app-long. Singleton is fine for shared data caches, configurations, or state containers (again, since one user). If the Blazor content is torn down and recreated (not common, but e.g., if you navigate away from and back to a page with BlazorWebView, it might restart the Blazor context), then a scoped service would reset – something to keep in mind if you see state “lost” unexpectedly when reloading the Blazor view.
Persisting State Across App Restarts: In Blazor WebAssembly, a page refresh wipes state unless you saved to localStorage or similar. In a MAUI app, there is no “browser refresh,” but the user can close the app or it can be terminated by the OS. If your application has important transient state (like unsaved form data or user preferences that you want to remember next time), you should explicitly persist it. You have a few options:
Use the ASP.NET ProtectedBrowserStorage or plain IJSRuntime.InvokeAsync("localStorage.setItem", ...) to store data in the WebView’s local storage. Yes, even the embedded WebView has its own local storage and indexedDB. This can be handy for reusing existing Blazor WASM logic that expects a browser storage – and it will persist between app runs (the WebView engine usually keeps data like a normal browser would, in an isolated cache for the app).
Use .NET MAUI storage APIs – e.g., Preferences.Set("key", value) or SecureStorage for sensitive info, or even a SQLite database via EF Core/SQLite. Since the .NET side can do anything, often it’s simpler to have a data service (in DI) that the Blazor components call, which under the hood uses a native storage mechanism. This way, you’re not tied to the quirks of browser storage and you can easily share the data with native parts of the app if needed.
For very transient UI state that doesn’t merit saving to disk, you can rely on the .NET objects staying in memory as long as the app is running. Unlike a web page, there’s no risk of the user pressing F5 to accidentally clear the UI – however, on mobile, if they background the app and the OS kills it to reclaim memory, that state is gone. So consider what needs persisting. For example, if PTDoc has a “current patient context” or some large data that’s expensive to fetch, caching it in a singleton service makes sense so that navigating between pages or reopening the Blazor part is fast.
Cascading Parameters and State Containers: Within Blazor, you should use proper state propagation patterns (unidirectional data flow). If multiple Blazor components need to share state (say a context object or a theme), prefer using a CascadingParameter or a dedicated state container service rather than relying on global variables. CascadingParameters work normally in hybrid – just ensure an ancestor provides the CascadingValue. If something isn’t flowing, double-check that the MAUI app’s page or layout is setting up the cascading value (in hybrid, usually the Blazor root component is the top – you might set cascading values in the App.razor or MainLayout just like a web app). Also, if using CascadingParameter by type, be mindful of name collisions (use the Name property to differentiate, if say both a native and web context object of the same type might be in scope).
In short, state management in Blazor Hybrid is simpler than Blazor Server (no circuits to worry about), and akin to Blazor WASM with added flexibility. Use DI singletons for app-wide data and services, avoid writing to component [Parameter] properties directly (standard Blazor practice) to prevent desync issues, and persist anything critical to stable storage since mobile apps don’t have a persistent in-memory state beyond their lifetime.
Navigation and Routing in a Hybrid Blazor App
Navigation in a Blazor hybrid application can happen at two levels: within the Blazor WebView (internal routing) and at the native app level (switching MAUI pages or shells).
Blazor Internal Navigation: If your MAUI app is primarily a single BlazorWebView that hosts a full Blazor SPA (single-page app), you will typically use Blazor’s built-in routing (NavLink, NavigationManager.NavigateTo, etc.) to navigate between views. This works exactly as it does on the web – the Blazor router updates the URL (which in a WebView will be a fake internal URL like app://0.0.0.0/page) and displays the desired component. The user doesn’t see a URL bar, but NavigationManager still holds a URI and base URI. For instance, NavigateTo("reports") will cause the BlazorWebView to load the Reports component (if configured in @page "/reports"). Deep-linking directly into a Blazor route from outside is not straightforward, since there’s no address bar, but you can programmatically tell the BlazorWebView what route to start at using the StartPath property or by passing parameters at startup
. The BlazorWebView.StartPath can be set (e.g., StartPath = "reports" in XAML) so that when the Blazor app loads, it navigates to that route instead of the default. Use this if, for example, your MAUI app has multiple entry points into the Blazor content.
Native Navigation (shell and multi-page apps): Some .NET MAUI apps use the Shell or multiple ContentPages to structure the app (for instance, a tab bar with some tabs being native pages and one tab being a Blazor page). In such cases, navigating between a Blazor page and a XAML page is outside of Blazor’s scope – you must use MAUI’s navigation mechanisms. For example, if the user is on a Blazor page and triggers a navigation to a wholly native page, you might call Shell.Current.GoToAsync("//NativePage") or push onto a NavigationPage. The Blazor component can initiate this via the DI bridge pattern described earlier (e.g., call a method on a service that the native layer listens to and then performs GoToAsync). Conversely, if a native page needs to show the Blazor UI, it might do something like Shell.Current.GoToAsync("//BlazorPage?startPath=XYZ") (passing parameters to instruct what the BlazorWebView should show, perhaps via query parameters the Blazor app can parse via NavigationManager). This requires designing a handshake where the native code can tell the Blazor code what to do on appearance.
Mixing Navigation Contexts Carefully: It’s important to avoid confusion between Blazor’s navigation context and MAUI’s. If your entire app is under the BlazorWebView (i.e., you use Blazor’s router for most screens), then treat it like a web app – NavigationManager is your main tool, and Shell navigation might not even be used except for perhaps modal dialogs or external links. If instead you only use Blazor for specific parts, you might disable Blazor’s internal navigation for those parts (e.g., have a single-page Blazor component that acts like a widget). In PTDoc’s scenario, where a large portion is Blazor, it might be simplest to keep the entire navigation flow inside Blazor for consistency between the web and mobile versions. If an agent does introduce native navigation, ensure that app state is passed appropriately (for example, if a user opens a detail page that is a native XAML page, you might need to provide it the context that was selected in the Blazor list). This could be done via the shared services (the native page can read a value from a singleton that the Blazor page set).
Intercepting Links: By default, if a user clicks an anchor (<a href="http://external.com">) in a BlazorWebView, the UrlLoading event of BlazorWebView is fired. You can handle this event to decide what to do – perhaps open the link in an external browser instead of within the WebView (since the WebView could navigate away from your app content if not handled). MAUI allows you to cancel or redirect these navigations
. As a best practice, open external web links in the device’s browser (to avoid trapping the user in the WebView). For internal links (those within your Blazor app, typically starting with “/”), Blazor intercepts them and uses its router. If you find that clicking links is doing nothing in the hybrid app, check that you have the <base href="/"> set correctly in index.html and that the Linker in the WebView is not interfering (shouldn’t, normally).
Hardware Back Button (Android): On Android devices, the hardware back button by default might close the app if not handled. If your Blazor app has its own navigation stack, you might want to intercept back presses: e.g., if the user is not on the home page, navigate back in Blazor rather than exiting. You can achieve this by hooking into the MAUI lifecycle or using a custom BackButtonBehavior. One approach: handle the back button pressed event in the page containing the BlazorWebView – use NavigationManager to navigate back (perhaps by calling NavigationManager.NavigateTo(previousUrl) or keeping your own stack). This is an advanced case, but mentionable if relevant. Agents should ensure the user isn’t stuck or accidentally exiting – if adding deep navigation in Blazor, consider the back button UX.
Summary: Use the appropriate navigation tool for the appropriate layer. Keep Blazor navigation internal to BlazorWebView and use MAUI navigation for structural app-level changes. Document any navigation integration so it’s clear which routes are Blazor’s concern and which are MAUI’s. A common mistake is trying to use NavigationManager to navigate to a native page or vice versa – this won’t work without a custom bridge. Plan the app’s navigation map upfront if possible (e.g., “All dashboard and detail pages are Blazor routes under the hood, accessible via NavigationManager, whereas the Settings page is a native XAML page accessible via Shell”).
Platform-Specific Considerations and Best Practices
Because Blazor Hybrid runs on diverse platforms (Android phones, iPhones, Windows desktop, macOS, etc.), agents need to account for some platform-specific differences and mobile app conventions:
Mobile UI/UX Adjustments: A Blazor app running in a mobile app should feel like a native mobile experience, not a website. This means you might want to disable text selection for non-editable content (to prevent the user from long-press highlighting labels, which feels webby)
, remove any default tap highlights on links/buttons (e.g., the blue flash on Android on tap)
, and ensure proper spacing for touch. You can achieve these via CSS in your Blazor app’s styles. For example, adding to your CSS:
*:not(input) { user-select: none; -webkit-user-select: none; }
* { -webkit-tap-highlight-color: transparent; }
will remove text selection and the tap highlight
. These little tweaks make the Blazor UI behave more like native.
Safe Area and Screen Notches: On iOS (and some Android devices), content can be obscured by the status bar, notch, or home indicator if you don’t respect safe areas. MAUI’s layouts typically handle safe area by default for native controls, but a WebView’s content might extend under system UI. Use CSS environment variables to pad your Blazor content within safe areas
. For example:
@supports (-webkit-touch-callout: none) {
  body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
  }
}
This CSS will add appropriate padding on iPhones with notches or devices with gesture bars
. Always test pages in landscape and portrait to ensure no important UI is cut off.
Keyboard and Input Behavior: When input fields are focused in the WebView (e.g., an <input> or <Textbox> in Blazor), the on-screen keyboard will appear on mobile. The WebView should handle resizing the content or scrolling, but in some cases you might need to ensure your Blazor layouts are mobile-friendly (avoiding fixed elements at bottom that could be covered). If you have an input that is at the very bottom, it might get hidden by the keyboard – consider adding enough padding or making it scrollable. This isn’t unique to Blazor, but worth noting for agents testing UI.
Performance on Low-End Devices: Mobile devices (especially older Androids) might struggle if your Blazor UI has very large DOMs or does extremely heavy processing on the UI thread. Keep list virtualization in mind (e.g., use <Virtualize> for long lists) and avoid unnecessary re-rendering. The good news is, because Blazor is running with full .NET, it can be faster than WASM (no IL interpretation overhead). Still, the bottleneck might be the WebView’s rendering. Profiling and watching memory usage on device is advisable for complex views.
WebView Quirks: Each platform’s WebView has its quirks. For example, Android WebView and iOS WKWebView both have a default background (white by default). If your app has a dark theme, you might see a white flash during startup or when navigating. To avoid this, you can customize the WebView background. One approach shown in community examples is removing the “Loading…” placeholder text from index.html (the MAUI template puts a <div id="app">Loading...</div> which appears until Blazor renders) and setting a matching background color in the WebView. For instance, one can remove the text and then in MainPage.xaml.cs do:
#if IOS || MACCATALYST
    Microsoft.Maui.Handlers.BlazorWebViewHandler.Mapper.AppendToMapping("BgFix", (handler, view) => {
        handler.PlatformView.Opaque = false;
    });
#endif
Or on Windows, adjust the WebView2 background as shown in Microsoft docs (setting DefaultBackgroundColor via a handler if needed)
. This ensures there isn’t a flash of white between the native splash screen and the Blazor content loading. Agents should be aware of these details if UI polish is a concern; a visible blank or flash can be jarring. The MAUI documentation suggests setting the WEBVIEW2_USER_DATA_FOLDER environment variable on Windows deployments (if installed to Program Files) to avoid WebView2 caching issues that can also lead to blank screens
 – basically a deployment note to ensure the WebView can write to a cache location.
Differences in Web APIs: Some web APIs might not be fully supported. For example, if you attempt to use certain advanced APIs (WebRTC, Service Workers for offline, etc.), the WebView might have them disabled or not up-to-date depending on OS. As of writing, most basic APIs (geolocation, localStorage, canvas, etc.) are available and behave normally. Just be cautious and test if you integrate something exotic.
Styling and Fonts: Ensure that any fonts or icons your Blazor app needs are included. If the web version references Google Fonts via an internet URL, consider bundling those fonts for offline use in the app or include them in the MAUI Resources. Likewise, verify that the default styling (bootstrap, etc., if used) looks good on mobile – sometimes adjusting CSS (larger touch targets, using responsive classes) is necessary so the UI doesn’t appear too small or too “desktop-like” on a phone.
Platform-specific Code Paths: If needed, you can detect if your Blazor is running in a specific platform and adjust behavior. For example, you might want to use a different CSS or disable an effect on iOS specifically. There’s no built-in “IsMobile” flag in Blazor, but you can inject say DeviceInfo.Current.Platform from .NET MAUI into a service and have Blazor read it, or use UserAgent via JSRuntime to detect the WebView’s user agent string. Use sparingly – ideally the Blazor app is written in a device-agnostic way except for known necessary tweaks.
Common Pitfalls and Guidance for Blazor MAUI Hybrid
Finally, to help agents avoid known mistakes, here’s a list of best practices and pitfalls specific to BlazorWebView in .NET MAUI:
Don’t Overlook Loading Indicators: A common cause of “invisible” or blank UI in hybrid apps is a component that is waiting on data without any UI feedback. In a MAUI app, this can look like the app just isn’t showing part of the screen, confusing users. Always initialize components with some visible content (loading spinners, skeletons, “Loading…” text) immediately, then fill in data later. For example, if PTDocMetricCard loads metrics, it should render a card frame and maybe a spinner or placeholder text on first render, rather than rendering nothing until data arrives. This way, on the MAUI app’s dashboard, the user sees that a section is loading instead of a mysterious empty gap. Agents should ensure every data-fetching component has a fallback UI state – this applies to web and hybrid, but is especially important for perceived performance on devices.
Conditional Rendering Logic: Be careful with @if blocks or other conditions that might inadvertently prevent content from rendering. For instance, wrapping a whole component in <AuthorizeView> or an @if that is false until data is non-null can lead to nothing showing up. In a hybrid app, there’s no browser dev console visible by default to catch this; it will just look blank. Better pattern: render a placeholder (or a disabled state) when the real content should not be shown yet, rather than not instantiating the component at all. This ties into the above point about always showing something.
Ensure Components Are Registered & Imported: If a Blazor component isn’t appearing at all in the MAUI app, it might be a registration issue. For example, if you added a new Razor component in a class library and use it in the Blazor app, you need to have that library referenced by the MAUI project and its namespace imported (in _Imports.razor or in the usage page). Forgetting to do this can result in the tag being silently not rendered (Blazor doesn’t know what <MyComponent> is). The fix is to update _Imports.razor with the new namespace or ensure the component’s assembly is included. This is a general Blazor issue, but when working across a shared web and hybrid project, it’s easy to miss because maybe the web one had an import but the MAUI one didn’t. In PTDoc’s case, if a component was added to the Shared RCL and not imported in the host, it could lead to it not showing up in the MAUI app. So agents must update imports and file casing whenever adding/moving components (remember component tags need to start with uppercase letter).
No In-Place Parameter Mutation: (This is a reiteration of standard Blazor rules, but worth reinforcing as a “pitfall” that leads to weird UI bugs.) Do not have a Blazor component set its own [Parameter] properties internally after initial render. This can cause state to get out of sync, especially if the parent isn’t aware. In hybrid, this is no different, but an agent might be tempted to, say, toggle a [Parameter] bool IsVisible inside the component. Instead, use internal state or notify the parent. This avoids cases where something works in one context but not when the parent re-renders. Our guardrails forbid this pattern.
JS Interop Timing: As noted, calling JS too early or without proper guards can fail. If an agent adds a JS call (for example, to render a chart) and it doesn’t work on MAUI, make sure it’s in OnAfterRenderAsync and not during OnInitialized. Also ensure the JS script is added to index.html. In MAUI, the content might not be interactive until everything loads, so if you absolutely must run some JS on startup, you could attach to the BlazorWebView’s BlazorWebViewInitialized event (which fires when the webview is ready)
, but typically the Blazor lifecycle is sufficient.
File System and Paths: If your Blazor code deals with file paths (e.g., reading a local JSON or image), remember that in hybrid the “current directory” or base URL might differ. A path like "/images/pic.png" might look for an images folder in the app’s native bundle or some web context. If you need to load a local file, consider using .NET file APIs (with FileSystem.AppDataDirectory etc.) via dependency injection. If you have images in wwwroot, use url('img.png') (relative paths) or "_content/YourLib/img.png" if coming from static assets of a library. Ensuring the MAUI app includes those files is key (MAUI will by default include wwwroot files as static assets if using the Razor SDK). A known limitation from Microsoft docs: Blazor Hybrid can’t display embedded resources via the Blazor <img> tag – if you try to use an image that isn’t accessible via an HTTP request or wwwroot, it won’t show
. So use the appropriate content pipeline (for example, don’t rely on Blazor’s <img src="data:image/..."> for large images; instead, consider providing a base64 or a file path accessible to the webview).
Device Permissions & WebView: If your Blazor code tries to use a browser API that requires permission (like Geolocation or Notification), in a web environment the browser would prompt the user. In a hybrid app, the WebView might not show a prompt. Instead, you should use the native permission request via MAUI Essentials (like Permissions.RequestAsync<Permissions.LocationWhenInUse>()) on the native side before invoking the JS or .NET functionality. Agents implementing a feature that uses device sensors or data should handle permissions at the MAUI level; otherwise the JS call might simply fail silently.
Testing on Real Devices: It’s crucial to test Blazor components on actual devices or emulators. Some issues (like the soft keyboard overlapping input, or performance on a low-end Android) are only evident there. As part of best practices, agents should verify their changes in both the Blazor Web app and the MAUI app. For example, if a component was fixed or added, check that it renders and functions correctly in a browser (Blazor WASM) and in the MAUI app’s WebView. It has happened that something worked in Chrome but not inside the WebView due to a missing CSS or a difference in engine. By manually testing both, these discrepancies can be caught early. Automated testing of UI might be limited (you could write unit tests for component logic with bUnit, but full integration tests on devices are harder), so manual testing is important whenever introducing changes that affect UI or state.
Logging and Diagnostics: If something is not working in the BlazorWebView and you can’t easily see why, remember you can enable logging. BlazorWebView can log diagnostic info if you configure logging providers in the MAUI app and set appropriate log levels (BlazorWebView logs to categories like “Microsoft.AspNetCore.Components.WebView.*”). You can also attach to the WebView’s dev tools: on Windows, press Alt+Shift+D (by default, if developer tools are enabled) to open the dev tools window for WebView2, or use browser dev tools via the device (for Android, you can use Chrome’s inspect devices feature; for iOS, Safari’s Web Inspector)
. Microsoft’s docs have a section on using browser dev tools with Blazor Hybrid
 – essentially, in Debug builds, AddBlazorWebViewDeveloperTools() allows that. This can help inspect the DOM, check console logs, and so forth, just like you would in a normal web app.
Keeping Up with .NET Updates: .NET MAUI and Blazor are evolving. Ensure the project is on a supported .NET version and test after upgrades. There have been cases (e.g., .NET 9 previews) where Blazor made changes that required updating the WebView or the underlying browser engine (as a Reddit thread noted, .NET 9 Blazor might not work on older WebView versions until updated)
. So, if something suddenly breaks after an update, it might be a version mismatch. Agents should watch release notes for anything related to BlazorWebView.
By observing these best practices and being aware of the differences from pure web or server Blazor, AI agents can confidently build features in the Blazor MAUI hybrid context without the common pitfalls. In summary, Blazor Hybrid combines two worlds – as an agent, always consider both sides: the web-based UI paradigms and the native app realities. Follow the official .NET MAUI Blazor guidance and the project-specific rules above to ensure smooth, responsive, and correct functionality on all platforms. This will prevent issues like components not appearing on certain devices, unresponsive UI due to sync calls, or broken integrations between the Blazor and native parts of PTDoc. With these guardrails, the AI assistant can generate Blazor components that respect the Blazor component model, fit into the MAUI app architecture, and deliver a native-quality user experience.





Sources


No file chosenNo file chosen
ChatGPT can make mistakes. OpenAI doesn't use BHD's Workspace workspace data to train its models.

Blazor Hybrid (MAUI) Application Behavior – Architecture, Lifecycle, and Integration
BlazorWebView Architecture in .NET MAUI (Blazor Hybrid)
In PTDoc’s .NET MAUI client, Blazor is integrated via the BlazorWebView control, creating a hybrid application. This means Razor components run natively on the device within the MAUI app’s .NET process, and render their output to an embedded Web View UI element
. Unlike Blazor WebAssembly (WASM) or Server, components in a BlazorWebView do not run in a browser sandbox or require WebAssembly at all – they execute on the normal .NET runtime (with full access to the device’s capabilities) and communicate with the WebView through a local interop channel
. The Blazor UI is essentially hosted inside a WebView, but all UI updates are driven by .NET code. In practice, this hybrid setup behaves much like client-side Blazor in terms of UI logic, just hosted in a native app instead of a standalone browser tab. How it’s set up: A MAUI Blazor app typically includes a wwwroot/index.html (the Blazor host page) and uses BlazorWebView on a XAML page to load it. For example, the MAUI MainPage.xaml might contain:
<BlazorWebView HostPage="wwwroot/index.html">
    <BlazorWebView.RootComponents>
        <RootComponent Selector="#app" ComponentType="{x:Type local:Main}" />
    </BlazorWebView.RootComponents>
</BlazorWebView>
This XAML (from the default template) points the BlazorWebView to the Blazor app’s host page and identifies the root Razor component to load (e.g. Main.razor) and where to render it in the DOM (Selector="#app" matches an element in index.html)
. Under the hood, the BlazorWebView will load the HTML from the app’s resources and initialize the Blazor runtime. In the MAUI startup (MauiProgram.cs), you must register Blazor services by calling builder.Services.AddMauiBlazorWebView(); (and usually enable debugging helpers in development via builder.Services.AddBlazorWebViewDeveloperTools();)
. Once configured, the MAUI app and Blazor share the same dependency injection (DI) container, allowing services and data to be easily shared across the native and web portions of the app. Browser Engine Differences: Because rendering is done in a WebView, the exact web engine varies by platform. For example, MAUI uses WebView2 (Edge Chromium) on Windows, Chromium WebView on Android, and WKWebView (Safari) on iOS/Mac
. This means that some HTML/CSS or JavaScript might behave slightly differently on each platform. Platform-specific web APIs may only be available on certain engines, and styling can differ. Always test UI on all target platforms to catch any inconsistencies
. Also note that on Windows, end users must have the WebView2 runtime installed for BlazorWebView to function
 (the developer template usually displays a notice or handles this).
Component Lifecycle in a MAUI Blazor Hybrid App
Blazor components in a BlazorWebView follow the same lifecycle conventions as in standard Blazor (since the Blazor framework running inside the WebView is essentially the same as Blazor WASM/Server). Each component goes through initialization (OnInitialized{Async}), parameter setting (OnParametersSet{Async} on each render), rendering, and after-render events (OnAfterRender{Async}) just as it would on the web. There is no server prerendering phase in a typical MAUI Blazor app, so you don’t have the split between a static prerender and interactive render as in Blazor Server. This means that OnAfterRenderAsync(firstRender:true) will run exactly once on the first render when the WebView has fully loaded the component, so you can safely put JavaScript initialization calls there without worrying about a non-interactive prerender pass. (In contrast, on Blazor Server prerendering, OnAfterRender is delayed until the client connects – not an issue for Blazor Hybrid, since it’s all local.) Essentially, the Blazor rendering flow – diffing the UI tree and only re-rendering on state change – works the same within BlazorWebView. However, it’s important to avoid heavy work on the UI thread during lifecycle events, especially on mobile devices. Just as in web or server Blazor, long synchronous operations in lifecycle methods (e.g. doing a big computation in OnInitialized) will block the UI from rendering. In a MAUI hybrid app, that can lead to visible delays or even the OS feeling the app is unresponsive. Always prefer asynchronous loading patterns: do minimal setup synchronously, then use await for longer tasks so the UI thread can render interim feedback. For example, start an API call in OnInitializedAsync, let the component render a placeholder UI (spinner, “Loading…” text, etc.), and then update the UI when the data arrives. This ensures the user sees something quickly, even if final data takes time – a known pitfall is leaving the screen blank while waiting for data, which is especially noticeable on app startup or slow networks. First Render and OnAfterRender: On the first render of a component, Blazor will invoke OnAfterRenderAsync(true) after the HTML is rendered to the WebView’s DOM. Use the firstRender flag to run one-time setup code here, such as initializing JS libraries or performing DOM manipulation that requires the element to be present. Subsequent renders will call OnAfterRenderAsync(false) and you typically should not repeat the initialization logic in those calls (to avoid duplicates). This pattern is the same as in web Blazor, but it’s worth emphasizing for hybrid apps because if a component doesn’t appear or update in the MAUI app, it could be that its JS initialization never ran. Always check that you placed any JS interop calls in the proper lifecycle hook with the appropriate guards. As a rule: Do not call JavaScript-dependent code during component initialization or before the WebView is ready. Instead, use OnAfterRenderAsync and conditional logic (if (firstRender)) so that such code runs only when the DOM is interactive. (This guidance was highlighted for server-side prerendering and MAUI scenarios because calling JS too early can fail – in MAUI’s case the WebView must be loaded.) Another note: StateHasChanged and Rendering – The Blazor rendering cycle inside MAUI will coalesce rapid state changes just like in other Blazor hosts. You generally should not call StateHasChanged() manually unless you’re updating state from an external callback (timer, etc.). Excessive calls can hurt performance. The BlazorWebView ensures that UI updates happen on the correct thread; if you do trigger UI changes from background threads, use InvokeAsync or similar patterns to marshal to the Blazor UI thread (just as you would in a normal Blazor app to avoid thread errors). The bottom line is that lifecycle best practices from Blazor (avoid long blocking code, use async, minimal StateHasChanged usage) all apply equally in the hybrid context.
Native and Blazor Integration Patterns (Communication Across the Divide)
One of the powerful features of Blazor Hybrid is that your Blazor components and native MAUI code can interact and share data, but this requires explicit bridges – the Blazor UI is essentially running in an isolated WebView, so it cannot directly reference MAUI UI elements, and vice versa. Agents must be mindful that you cannot simply place MAUI XAML controls inside a Blazor .razor file, nor call Blazor component methods directly from MAUI code without a mechanism. Below we outline common integration approaches:
Mixing Native and Blazor UI: If you need to show native MAUI controls (say a Camera preview or a platform-specific picker) alongside Blazor content, the approach is to compose them in the MAUI XAML layout, not to embed one into the other. For example, you might create a MAUI ContentPage that has a Grid with a BlazorWebView in one row and a native control (or overlay) in another row or on top. You can toggle the native control’s visibility or position it absolute over the BlazorWebView when needed. Do not attempt to directly add a MAUI control in the Razor component markup – that won’t work, as the Razor markup only knows how to render HTML/Blazor components inside the WebView
. Instead, have the MAUI page own the layout and show/hide native elements in response to events (for instance, a Blazor button could trigger showing a native modal or overlay through an event, as discussed next).
Blazor-to-Native Calls (invoking platform features): The recommended pattern is to use dependency injection and an intermediary service to funnel calls or data between Blazor and native code
. For example, you can create a singleton service (say, IDeviceService) that is added to the DI container in MauiProgram. This service can expose methods and events for various actions. In a Razor component, you inject this DeviceService and call a method (e.g. DeviceService.TriggerCameraCapture()), which internally fires an event. On the native side (in the MAUI page or wherever appropriate), you have access to the same singleton service (since MAUI and Blazor share the IServiceProvider). The native code can subscribe to the event (or check a property) and when it sees the “TriggerCameraCapture” event, it invokes the actual platform-specific API (such as launching the camera or opening a native view). This way, the Blazor component remains unaware of platform details – it just calls a service method – and the native layer handles it, or vice versa. By injecting a common service into both Blazor and MAUI, you create a bridge for method calls and data flow
. For instance:
// In MauiProgram.cs
builder.Services.AddSingleton<DeviceBridge>();  // a service for bridging calls

// A simple bridge service
public class DeviceBridge {
    // e.g., event for a native action
    public event EventHandler? OnCaptureRequested; 

    public void RequestCapture() {
        OnCaptureRequested?.Invoke(this, EventArgs.Empty);
    }

    // possibly a callback from native to Blazor via event as well
    public event EventHandler<string>? OnDataReceived;
    public void RaiseDataReceived(string data) {
        OnDataReceived?.Invoke(this, data);
    }
}
In a Razor component you might use this service as:
@inject DeviceBridge Bridge

<button @onclick="@(()=> Bridge.RequestCapture())">Take Photo</button>
And in the MAUI page code-behind:
// Retrieve the same singleton service instance
var bridge = this.Handler.MauiContext.Services.GetService<DeviceBridge>();
if(bridge != null) {
    bridge.OnCaptureRequested += async (s,e) => {
        // Code to open camera and capture photo, then:
        string photoPath = await CapturePhotoAsync();
        bridge.RaiseDataReceived(photoPath);
    };
}
Here the Blazor UI triggers RequestCapture(), the native side listens and opens the camera, then returns the result via RaiseDataReceived, which the Blazor side could also listen to (e.g., the Razor component could subscribe to Bridge.OnDataReceived to get the photo path). This pattern cleanly separates concerns and works cross-platform.
Native-to-Blazor Calls: The above covers Blazor initiating an action. If a native MAUI element (like a hardware back button or a native menu) needs to cause something in the Blazor UI, you also use the DI bridge idea but in reverse: call a method on the service from the native side, and have the Blazor component subscribe to an event or poll a property. Another approach provided by the framework is BlazorWebView.TryDispatchAsync, which allows native code to run a callback within the Blazor renderer’s synchronization context
. For example, suppose you have a native MAUI Button and you want it to navigate the Blazor WebView to a different page. You can do:
// Assuming _blazorWebView is your BlazorWebView instance on the page
await _blazorWebView.TryDispatchAsync(sp => {
    var navManager = sp.GetRequiredService<NavigationManager>();
    navManager.NavigateTo("some/blazor/page");
});
This will safely obtain the Blazor NavigationManager from the Blazor WebView’s service provider and call it to navigate within the Blazor routing context
. TryDispatchAsync is powerful for accessing any scoped services or functionality from outside. Use it whenever you need to interact with Blazor-only services (like NavigationManager or JSRuntime) as a result of a native UI event.
JavaScript Interop vs. Direct .NET Calls: In a purely web Blazor app, one might use JavaScript Interop to call into native device features (for example, using JavaScript to invoke a mobile capability via a Cordova-like plugin or Web API). In a Blazor Hybrid app, you have the full .NET API surface available directly, so you usually don’t need JS Interop to call device APIs – you’d call them in .NET via MAUI libraries or dependency injection. JS interop is still available (and we discuss specifics in the next section), but consider whether a direct .NET approach is cleaner. For instance, to get geolocation in a hybrid app, you could just use Xamarin/MAUI Essentials Geolocation.GetLastKnownLocationAsync() in a service, rather than injecting JS to call navigator.geolocation. The hybrid model lets you leverage native code where possible, using Blazor mainly for UI.
No Shared UI State by Default: Keep in mind that each BlazorWebView has its own isolated rendering context and (by default) a separate DI scope for scoped services. Singletons are shared app-wide (including between MAUI and Blazor), but scoped services are tied to a particular BlazorWebView instance. If your app only has one BlazorWebView (common case), you can treat scoped services as effectively single-instance for that running app. But if you ever had multiple BlazorWebView controls (for example, two different pages each hosting some Blazor content), each would get its own copy of scoped services. Plan accordingly for where to store shared state: truly global state can use singletons or static singletons (since in MAUI there’s one user), but per-page or per-component state might belong in scoped or cascading parameters. MAUI’s Blazor integration also provides ways for the native side to access a Blazor component’s scoped service provider if needed (as shown with TryDispatchAsync).
In summary, agents must explicitly design the communication pathways between Blazor and the native part of the app. The DI bridge approach is usually the safest and most testable way to coordinate actions (since it keeps a clean separation of concerns and uses strongly-typed .NET calls). Avoid hacks like invoking JavaScript to manipulate XAML UI or vice versa – always prefer a .NET interop (through services/events or TryDispatchAsync) or a clearly defined JS-call if absolutely needed.
JavaScript Interop in Blazor Hybrid Apps
Blazor’s standard JavaScript Interop (IJSRuntime) works in a hybrid app, but there are some nuances:
JS Runtime Environment: In BlazorWebView, the JavaScript executes inside the embedded WebView’s context (e.g., the WebView2 or WKWebView JavaScript engine). Calls you make with IJSRuntime.InvokeAsync from .NET will be dispatched to that WebView’s JavaScript runtime, just like in a web app. The difference is that the .NET code is running natively, so behind the scenes the interop call goes over a native->web boundary (likely via a local IPC channel between .NET and the WebView). This is usually seamless – you can await jsRuntime.InvokeAsync<string>("myFunc", arg1) and it will return a result as expected. Performance of interop is generally fast on modern devices, but not as fast as an in-process method call, so still treat it as an asynchronous, potentially UI-blocking operation. Avoid very frequent JS calls in tight loops; batch work if you can, or do more logic on one side to reduce chatty calls.
Including Scripts and Libraries: In a hybrid app, there is no network fetch of scripts by default (unless your Blazor app explicitly fetches CDN resources). Typically, any JS libraries your components need (for example, a charting library) should be added to your wwwroot/index.html or served as static files in the wwwroot folder, similar to a Blazor WASM app. Since the MAUI Blazor app uses a local HTML file, you need to ensure all references are either to local files or to accessible web URLs. If your Blazor WASM app relied on an external script (CDN), consider bundling it for offline use in the hybrid app, or at least be aware that the app will need internet to fetch it. Also remember to add any CSS files your components need into the app. If a component uses certain CSS (e.g., from a library or an icon font), make sure the MAUI host includes those static assets; otherwise the component might appear broken on the native app.
Limitations of the WebView Sandbox: The WebView running your Blazor UI is similar to a full browser, but on some platforms it may be a sandboxed environment. Certain browser APIs might be restricted or not available. For example, things like window.alert or window.open may behave differently on mobile – window.alert might not show any dialog on some platforms (or show a native alert that could disrupt the user experience). Another example: file access in the browser context (like using JavaScript to read local files) won’t magically grant access to the device’s file system beyond the WebView’s sandbox. In general, assume the JS environment is constrained – if you need functionality outside of pure web capabilities, use .NET to accomplish it. The BlazorWebView environment also doesn’t have a traditional browser address bar or dev console visible to the user, so debugging might require attaching external dev tools (see Debugging section below).
Invoking .NET from JavaScript: Blazor supports calling static .NET methods from JS via [JSInvokable]. In hybrid, this works too, but note that since .NET is not running in a browser thread, the performance is similar to any interop. If you have some JavaScript that needs to call back into .NET (perhaps to notify of something), you can still use DotNet.invokeMethodAsync or pass a .NET Object Ref to JS and call methods on it. This can be useful for libraries that expect to callback into .NET (for instance, registering a JS event that triggers a .NET handler). Just be mindful of threading – Blazor will ensure the calls get to the right context.
Use Case – JS for UI Libraries: One common use is embedding a JS UI library (like charts or maps) in a Blazor component. In a hybrid app, you do the same as usual: include the JS and CSS, and initialize the library in OnAfterRenderAsync(firstRender). If something isn’t showing up, double-check that:
The script is actually loaded (open developer tools to see if there are 404 errors or similar).
You only call the JS after the element is in the DOM (hence the OnAfterRender(firstRender) pattern).
If using Blazor Server or other modes as well, guard the call (e.g., don’t run on prerender – not applicable to pure MAUI, but relevant if code is shared with server mode).
In MAUI, ensure any special web security settings are handled if needed (e.g., WKWebView might block insecure content; if loading any http resources on iOS, you might need to configure App Transport Security or use https).
In summary, JavaScript interop in MAUI Blazor is a powerful tool but often optional – use it for what it’s good at (web UI manipulations, calling existing JS libs) but use .NET for anything platform-native. And always test those interop pieces on actual devices; an API that works in a desktop WebView might behave differently on iOS WebKit.
State Management and Persistence in Blazor Hybrid
Managing state in a Blazor Hybrid app shares many similarities with Blazor WebAssembly, with a few key differences in scope and lifetime:
Per-User State: In a Blazor WebAssembly or MAUI app, there is only one user/context, so using a static or singleton to hold app-wide state (like a global settings object, or cached data) is acceptable and will not cross user boundaries. In Blazor Server, that would be dangerous (because it’s multi-user), but in a MAUI app each app instance is a single user environment. Thus, PTDoc’s hybrid app can use singletons or static singletons for things like a selected patient ID, without risk of leaking data between users (there’s no server-side shared memory concern). That said, if the project ever introduces multi-user (or multiple windows), we’d revisit this. For now, agents can treat the Blazor portion as single-user and simplify state management accordingly (no circuit handling needed, etc.).
Scoped vs. Singleton Services: As noted, services registered as Scoped in a BlazorWebView are tied to the lifetime of the BlazorWebView’s navigation context. In most cases, the Blazor content lives for the duration of the page, possibly the entire app session (unless you remove and re-add the BlazorWebView). For practical purposes, many apps just use Singleton services for most data or state so that it persists as long as the app runs (because mobile apps can be suspended or resumed, but if not fully killed, the singleton remains in memory). Use Scoped if you specifically want a fresh instance of a service for the Blazor UI each time it’s created or reset, but note that if your MAUI app never disposes the BlazorWebView, the scope might effectively be app-long. Singleton is fine for shared data caches, configurations, or state containers (again, since one user). If the Blazor content is torn down and recreated (not common, but e.g., if you navigate away from and back to a page with BlazorWebView, it might restart the Blazor context), then a scoped service would reset – something to keep in mind if you see state “lost” unexpectedly when reloading the Blazor view.
Persisting State Across App Restarts: In Blazor WebAssembly, a page refresh wipes state unless you saved to localStorage or similar. In a MAUI app, there is no “browser refresh,” but the user can close the app or it can be terminated by the OS. If your application has important transient state (like unsaved form data or user preferences that you want to remember next time), you should explicitly persist it. You have a few options:
Use the ASP.NET ProtectedBrowserStorage or plain IJSRuntime.InvokeAsync("localStorage.setItem", ...) to store data in the WebView’s local storage. Yes, even the embedded WebView has its own local storage and indexedDB. This can be handy for reusing existing Blazor WASM logic that expects a browser storage – and it will persist between app runs (the WebView engine usually keeps data like a normal browser would, in an isolated cache for the app).
Use .NET MAUI storage APIs – e.g., Preferences.Set("key", value) or SecureStorage for sensitive info, or even a SQLite database via EF Core/SQLite. Since the .NET side can do anything, often it’s simpler to have a data service (in DI) that the Blazor components call, which under the hood uses a native storage mechanism. This way, you’re not tied to the quirks of browser storage and you can easily share the data with native parts of the app if needed.
For very transient UI state that doesn’t merit saving to disk, you can rely on the .NET objects staying in memory as long as the app is running. Unlike a web page, there’s no risk of the user pressing F5 to accidentally clear the UI – however, on mobile, if they background the app and the OS kills it to reclaim memory, that state is gone. So consider what needs persisting. For example, if PTDoc has a “current patient context” or some large data that’s expensive to fetch, caching it in a singleton service makes sense so that navigating between pages or reopening the Blazor part is fast.
Cascading Parameters and State Containers: Within Blazor, you should use proper state propagation patterns (unidirectional data flow). If multiple Blazor components need to share state (say a context object or a theme), prefer using a CascadingParameter or a dedicated state container service rather than relying on global variables. CascadingParameters work normally in hybrid – just ensure an ancestor provides the CascadingValue. If something isn’t flowing, double-check that the MAUI app’s page or layout is setting up the cascading value (in hybrid, usually the Blazor root component is the top – you might set cascading values in the App.razor or MainLayout just like a web app). Also, if using CascadingParameter by type, be mindful of name collisions (use the Name property to differentiate, if say both a native and web context object of the same type might be in scope).
In short, state management in Blazor Hybrid is simpler than Blazor Server (no circuits to worry about), and akin to Blazor WASM with added flexibility. Use DI singletons for app-wide data and services, avoid writing to component [Parameter] properties directly (standard Blazor practice) to prevent desync issues, and persist anything critical to stable storage since mobile apps don’t have a persistent in-memory state beyond their lifetime.
Navigation and Routing in a Hybrid Blazor App
Navigation in a Blazor hybrid application can happen at two levels: within the Blazor WebView (internal routing) and at the native app level (switching MAUI pages or shells).
Blazor Internal Navigation: If your MAUI app is primarily a single BlazorWebView that hosts a full Blazor SPA (single-page app), you will typically use Blazor’s built-in routing (NavLink, NavigationManager.NavigateTo, etc.) to navigate between views. This works exactly as it does on the web – the Blazor router updates the URL (which in a WebView will be a fake internal URL like app://0.0.0.0/page) and displays the desired component. The user doesn’t see a URL bar, but NavigationManager still holds a URI and base URI. For instance, NavigateTo("reports") will cause the BlazorWebView to load the Reports component (if configured in @page "/reports"). Deep-linking directly into a Blazor route from outside is not straightforward, since there’s no address bar, but you can programmatically tell the BlazorWebView what route to start at using the StartPath property or by passing parameters at startup
. The BlazorWebView.StartPath can be set (e.g., StartPath = "reports" in XAML) so that when the Blazor app loads, it navigates to that route instead of the default. Use this if, for example, your MAUI app has multiple entry points into the Blazor content.
Native Navigation (shell and multi-page apps): Some .NET MAUI apps use the Shell or multiple ContentPages to structure the app (for instance, a tab bar with some tabs being native pages and one tab being a Blazor page). In such cases, navigating between a Blazor page and a XAML page is outside of Blazor’s scope – you must use MAUI’s navigation mechanisms. For example, if the user is on a Blazor page and triggers a navigation to a wholly native page, you might call Shell.Current.GoToAsync("//NativePage") or push onto a NavigationPage. The Blazor component can initiate this via the DI bridge pattern described earlier (e.g., call a method on a service that the native layer listens to and then performs GoToAsync). Conversely, if a native page needs to show the Blazor UI, it might do something like Shell.Current.GoToAsync("//BlazorPage?startPath=XYZ") (passing parameters to instruct what the BlazorWebView should show, perhaps via query parameters the Blazor app can parse via NavigationManager). This requires designing a handshake where the native code can tell the Blazor code what to do on appearance.
Mixing Navigation Contexts Carefully: It’s important to avoid confusion between Blazor’s navigation context and MAUI’s. If your entire app is under the BlazorWebView (i.e., you use Blazor’s router for most screens), then treat it like a web app – NavigationManager is your main tool, and Shell navigation might not even be used except for perhaps modal dialogs or external links. If instead you only use Blazor for specific parts, you might disable Blazor’s internal navigation for those parts (e.g., have a single-page Blazor component that acts like a widget). In PTDoc’s scenario, where a large portion is Blazor, it might be simplest to keep the entire navigation flow inside Blazor for consistency between the web and mobile versions. If an agent does introduce native navigation, ensure that app state is passed appropriately (for example, if a user opens a detail page that is a native XAML page, you might need to provide it the context that was selected in the Blazor list). This could be done via the shared services (the native page can read a value from a singleton that the Blazor page set).
Intercepting Links: By default, if a user clicks an anchor (<a href="http://external.com">) in a BlazorWebView, the UrlLoading event of BlazorWebView is fired. You can handle this event to decide what to do – perhaps open the link in an external browser instead of within the WebView (since the WebView could navigate away from your app content if not handled). MAUI allows you to cancel or redirect these navigations
. As a best practice, open external web links in the device’s browser (to avoid trapping the user in the WebView). For internal links (those within your Blazor app, typically starting with “/”), Blazor intercepts them and uses its router. If you find that clicking links is doing nothing in the hybrid app, check that you have the <base href="/"> set correctly in index.html and that the Linker in the WebView is not interfering (shouldn’t, normally).
Hardware Back Button (Android): On Android devices, the hardware back button by default might close the app if not handled. If your Blazor app has its own navigation stack, you might want to intercept back presses: e.g., if the user is not on the home page, navigate back in Blazor rather than exiting. You can achieve this by hooking into the MAUI lifecycle or using a custom BackButtonBehavior. One approach: handle the back button pressed event in the page containing the BlazorWebView – use NavigationManager to navigate back (perhaps by calling NavigationManager.NavigateTo(previousUrl) or keeping your own stack). This is an advanced case, but mentionable if relevant. Agents should ensure the user isn’t stuck or accidentally exiting – if adding deep navigation in Blazor, consider the back button UX.
Summary: Use the appropriate navigation tool for the appropriate layer. Keep Blazor navigation internal to BlazorWebView and use MAUI navigation for structural app-level changes. Document any navigation integration so it’s clear which routes are Blazor’s concern and which are MAUI’s. A common mistake is trying to use NavigationManager to navigate to a native page or vice versa – this won’t work without a custom bridge. Plan the app’s navigation map upfront if possible (e.g., “All dashboard and detail pages are Blazor routes under the hood, accessible via NavigationManager, whereas the Settings page is a native XAML page accessible via Shell”).
Platform-Specific Considerations and Best Practices
Because Blazor Hybrid runs on diverse platforms (Android phones, iPhones, Windows desktop, macOS, etc.), agents need to account for some platform-specific differences and mobile app conventions:
Mobile UI/UX Adjustments: A Blazor app running in a mobile app should feel like a native mobile experience, not a website. This means you might want to disable text selection for non-editable content (to prevent the user from long-press highlighting labels, which feels webby)
, remove any default tap highlights on links/buttons (e.g., the blue flash on Android on tap)
, and ensure proper spacing for touch. You can achieve these via CSS in your Blazor app’s styles. For example, adding to your CSS:
*:not(input) { user-select: none; -webkit-user-select: none; }
* { -webkit-tap-highlight-color: transparent; }
will remove text selection and the tap highlight
. These little tweaks make the Blazor UI behave more like native.
Safe Area and Screen Notches: On iOS (and some Android devices), content can be obscured by the status bar, notch, or home indicator if you don’t respect safe areas. MAUI’s layouts typically handle safe area by default for native controls, but a WebView’s content might extend under system UI. Use CSS environment variables to pad your Blazor content within safe areas
. For example:
@supports (-webkit-touch-callout: none) {
  body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
  }
}
This CSS will add appropriate padding on iPhones with notches or devices with gesture bars
. Always test pages in landscape and portrait to ensure no important UI is cut off.
Keyboard and Input Behavior: When input fields are focused in the WebView (e.g., an <input> or <Textbox> in Blazor), the on-screen keyboard will appear on mobile. The WebView should handle resizing the content or scrolling, but in some cases you might need to ensure your Blazor layouts are mobile-friendly (avoiding fixed elements at bottom that could be covered). If you have an input that is at the very bottom, it might get hidden by the keyboard – consider adding enough padding or making it scrollable. This isn’t unique to Blazor, but worth noting for agents testing UI.
Performance on Low-End Devices: Mobile devices (especially older Androids) might struggle if your Blazor UI has very large DOMs or does extremely heavy processing on the UI thread. Keep list virtualization in mind (e.g., use <Virtualize> for long lists) and avoid unnecessary re-rendering. The good news is, because Blazor is running with full .NET, it can be faster than WASM (no IL interpretation overhead). Still, the bottleneck might be the WebView’s rendering. Profiling and watching memory usage on device is advisable for complex views.
WebView Quirks: Each platform’s WebView has its quirks. For example, Android WebView and iOS WKWebView both have a default background (white by default). If your app has a dark theme, you might see a white flash during startup or when navigating. To avoid this, you can customize the WebView background. One approach shown in community examples is removing the “Loading…” placeholder text from index.html (the MAUI template puts a <div id="app">Loading...</div> which appears until Blazor renders) and setting a matching background color in the WebView. For instance, one can remove the text and then in MainPage.xaml.cs do:
#if IOS || MACCATALYST
    Microsoft.Maui.Handlers.BlazorWebViewHandler.Mapper.AppendToMapping("BgFix", (handler, view) => {
        handler.PlatformView.Opaque = false;
    });
#endif
Or on Windows, adjust the WebView2 background as shown in Microsoft docs (setting DefaultBackgroundColor via a handler if needed)
. This ensures there isn’t a flash of white between the native splash screen and the Blazor content loading. Agents should be aware of these details if UI polish is a concern; a visible blank or flash can be jarring. The MAUI documentation suggests setting the WEBVIEW2_USER_DATA_FOLDER environment variable on Windows deployments (if installed to Program Files) to avoid WebView2 caching issues that can also lead to blank screens
 – basically a deployment note to ensure the WebView can write to a cache location.
Differences in Web APIs: Some web APIs might not be fully supported. For example, if you attempt to use certain advanced APIs (WebRTC, Service Workers for offline, etc.), the WebView might have them disabled or not up-to-date depending on OS. As of writing, most basic APIs (geolocation, localStorage, canvas, etc.) are available and behave normally. Just be cautious and test if you integrate something exotic.
Styling and Fonts: Ensure that any fonts or icons your Blazor app needs are included. If the web version references Google Fonts via an internet URL, consider bundling those fonts for offline use in the app or include them in the MAUI Resources. Likewise, verify that the default styling (bootstrap, etc., if used) looks good on mobile – sometimes adjusting CSS (larger touch targets, using responsive classes) is necessary so the UI doesn’t appear too small or too “desktop-like” on a phone.
Platform-specific Code Paths: If needed, you can detect if your Blazor is running in a specific platform and adjust behavior. For example, you might want to use a different CSS or disable an effect on iOS specifically. There’s no built-in “IsMobile” flag in Blazor, but you can inject say DeviceInfo.Current.Platform from .NET MAUI into a service and have Blazor read it, or use UserAgent via JSRuntime to detect the WebView’s user agent string. Use sparingly – ideally the Blazor app is written in a device-agnostic way except for known necessary tweaks.
Common Pitfalls and Guidance for Blazor MAUI Hybrid
Finally, to help agents avoid known mistakes, here’s a list of best practices and pitfalls specific to BlazorWebView in .NET MAUI:
Don’t Overlook Loading Indicators: A common cause of “invisible” or blank UI in hybrid apps is a component that is waiting on data without any UI feedback. In a MAUI app, this can look like the app just isn’t showing part of the screen, confusing users. Always initialize components with some visible content (loading spinners, skeletons, “Loading…” text) immediately, then fill in data later. For example, if PTDocMetricCard loads metrics, it should render a card frame and maybe a spinner or placeholder text on first render, rather than rendering nothing until data arrives. This way, on the MAUI app’s dashboard, the user sees that a section is loading instead of a mysterious empty gap. Agents should ensure every data-fetching component has a fallback UI state – this applies to web and hybrid, but is especially important for perceived performance on devices.
Conditional Rendering Logic: Be careful with @if blocks or other conditions that might inadvertently prevent content from rendering. For instance, wrapping a whole component in <AuthorizeView> or an @if that is false until data is non-null can lead to nothing showing up. In a hybrid app, there’s no browser dev console visible by default to catch this; it will just look blank. Better pattern: render a placeholder (or a disabled state) when the real content should not be shown yet, rather than not instantiating the component at all. This ties into the above point about always showing something.
Ensure Components Are Registered & Imported: If a Blazor component isn’t appearing at all in the MAUI app, it might be a registration issue. For example, if you added a new Razor component in a class library and use it in the Blazor app, you need to have that library referenced by the MAUI project and its namespace imported (in _Imports.razor or in the usage page). Forgetting to do this can result in the tag being silently not rendered (Blazor doesn’t know what <MyComponent> is). The fix is to update _Imports.razor with the new namespace or ensure the component’s assembly is included. This is a general Blazor issue, but when working across a shared web and hybrid project, it’s easy to miss because maybe the web one had an import but the MAUI one didn’t. In PTDoc’s case, if a component was added to the Shared RCL and not imported in the host, it could lead to it not showing up in the MAUI app. So agents must update imports and file casing whenever adding/moving components (remember component tags need to start with uppercase letter).
No In-Place Parameter Mutation: (This is a reiteration of standard Blazor rules, but worth reinforcing as a “pitfall” that leads to weird UI bugs.) Do not have a Blazor component set its own [Parameter] properties internally after initial render. This can cause state to get out of sync, especially if the parent isn’t aware. In hybrid, this is no different, but an agent might be tempted to, say, toggle a [Parameter] bool IsVisible inside the component. Instead, use internal state or notify the parent. This avoids cases where something works in one context but not when the parent re-renders. Our guardrails forbid this pattern.
JS Interop Timing: As noted, calling JS too early or without proper guards can fail. If an agent adds a JS call (for example, to render a chart) and it doesn’t work on MAUI, make sure it’s in OnAfterRenderAsync and not during OnInitialized. Also ensure the JS script is added to index.html. In MAUI, the content might not be interactive until everything loads, so if you absolutely must run some JS on startup, you could attach to the BlazorWebView’s BlazorWebViewInitialized event (which fires when the webview is ready)
, but typically the Blazor lifecycle is sufficient.
File System and Paths: If your Blazor code deals with file paths (e.g., reading a local JSON or image), remember that in hybrid the “current directory” or base URL might differ. A path like "/images/pic.png" might look for an images folder in the app’s native bundle or some web context. If you need to load a local file, consider using .NET file APIs (with FileSystem.AppDataDirectory etc.) via dependency injection. If you have images in wwwroot, use url('img.png') (relative paths) or "_content/YourLib/img.png" if coming from static assets of a library. Ensuring the MAUI app includes those files is key (MAUI will by default include wwwroot files as static assets if using the Razor SDK). A known limitation from Microsoft docs: Blazor Hybrid can’t display embedded resources via the Blazor <img> tag – if you try to use an image that isn’t accessible via an HTTP request or wwwroot, it won’t show
. So use the appropriate content pipeline (for example, don’t rely on Blazor’s <img src="data:image/..."> for large images; instead, consider providing a base64 or a file path accessible to the webview).
Device Permissions & WebView: If your Blazor code tries to use a browser API that requires permission (like Geolocation or Notification), in a web environment the browser would prompt the user. In a hybrid app, the WebView might not show a prompt. Instead, you should use the native permission request via MAUI Essentials (like Permissions.RequestAsync<Permissions.LocationWhenInUse>()) on the native side before invoking the JS or .NET functionality. Agents implementing a feature that uses device sensors or data should handle permissions at the MAUI level; otherwise the JS call might simply fail silently.
Testing on Real Devices: It’s crucial to test Blazor components on actual devices or emulators. Some issues (like the soft keyboard overlapping input, or performance on a low-end Android) are only evident there. As part of best practices, agents should verify their changes in both the Blazor Web app and the MAUI app. For example, if a component was fixed or added, check that it renders and functions correctly in a browser (Blazor WASM) and in the MAUI app’s WebView. It has happened that something worked in Chrome but not inside the WebView due to a missing CSS or a difference in engine. By manually testing both, these discrepancies can be caught early. Automated testing of UI might be limited (you could write unit tests for component logic with bUnit, but full integration tests on devices are harder), so manual testing is important whenever introducing changes that affect UI or state.
Logging and Diagnostics: If something is not working in the BlazorWebView and you can’t easily see why, remember you can enable logging. BlazorWebView can log diagnostic info if you configure logging providers in the MAUI app and set appropriate log levels (BlazorWebView logs to categories like “Microsoft.AspNetCore.Components.WebView.*”). You can also attach to the WebView’s dev tools: on Windows, press Alt+Shift+D (by default, if developer tools are enabled) to open the dev tools window for WebView2, or use browser dev tools via the device (for Android, you can use Chrome’s inspect devices feature; for iOS, Safari’s Web Inspector)
. Microsoft’s docs have a section on using browser dev tools with Blazor Hybrid
 – essentially, in Debug builds, AddBlazorWebViewDeveloperTools() allows that. This can help inspect the DOM, check console logs, and so forth, just like you would in a normal web app.
Keeping Up with .NET Updates: .NET MAUI and Blazor are evolving. Ensure the project is on a supported .NET version and test after upgrades. There have been cases (e.g., .NET 9 previews) where Blazor made changes that required updating the WebView or the underlying browser engine (as a Reddit thread noted, .NET 9 Blazor might not work on older WebView versions until updated)
. So, if something suddenly breaks after an update, it might be a version mismatch. Agents should watch release notes for anything related to BlazorWebView.
By observing these best practices and being aware of the differences from pure web or server Blazor, AI agents can confidently build features in the Blazor MAUI hybrid context without the common pitfalls. In summary, Blazor Hybrid combines two worlds – as an agent, always consider both sides: the web-based UI paradigms and the native app realities. Follow the official .NET MAUI Blazor guidance and the project-specific rules above to ensure smooth, responsive, and correct functionality on all platforms. This will prevent issues like components not appearing on certain devices, unresponsive UI due to sync calls, or broken integrations between the Blazor and native parts of PTDoc. With these guardrails, the AI assistant can generate Blazor components that respect the Blazor component model, fit into the MAUI app architecture, and deliver a native-quality user experience.
Citations

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0

ASP.NET Core Blazor Hybrid | Microsoft Learn

https://learn.microsoft.com/en-us/aspnet/core/blazor/hybrid
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d

c# - How to use .Net MAUI controls in a razor component in .Net MAUI Blazor app - Stack Overflow

https://stackoverflow.com/questions/74015992/how-to-use-net-maui-controls-in-a-razor-component-in-net-maui-blazor-app

c# - How to use .Net MAUI controls in a razor component in .Net MAUI Blazor app - Stack Overflow

https://stackoverflow.com/questions/74015992/how-to-use-net-maui-controls-in-a-razor-component-in-net-maui-blazor-app

ASP.NET Core Blazor Hybrid | Microsoft Learn

https://learn.microsoft.com/en-us/aspnet/core/blazor/hybrid

ASP.NET Core Blazor Hybrid | Microsoft Learn

https://learn.microsoft.com/en-us/aspnet/core/blazor/hybrid
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0

.NET MAUI Blazor - Best practices for mobile UI - DEV Community

https://dev.to/mhrastegari/net-maui-blazor-best-practices-for-mobile-ui-4def

.NET MAUI Blazor - Best practices for mobile UI - DEV Community

https://dev.to/mhrastegari/net-maui-blazor-best-practices-for-mobile-ui-4def

.NET MAUI Blazor - Best practices for mobile UI - DEV Community

https://dev.to/mhrastegari/net-maui-blazor-best-practices-for-mobile-ui-4def

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0

ASP.NET Core Blazor Hybrid | Microsoft Learn

https://learn.microsoft.com/en-us/aspnet/core/blazor/hybrid
Blazor-Context.md

file://file_000000004150722f974b52957d3f2d5d

Host a Blazor web app in a .NET MAUI app using BlazorWebView - .NET MAUI | Microsoft Learn

https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/blazorwebview?view=net-maui-10.0

Maui Blazor Hybrid apps with .NET 9 might not work ... - Reddit

https://www.reddit.com/r/dotnetMAUI/comments/1i80a1o/warning_maui_blazor_hybrid_apps_with_net_9_might/
All Sources

learn.microsoft
Blazor-Context.md

stackoverflow

dev

reddit