Blazor Application Behavior – Key Mechanics and Guardrails for PTDoc
Blazor Component Rendering and Lifecycle

Rendering Flow: Blazor components render by building an in-memory render tree that efficiently updates the browser DOM. A component always renders on first use, and thereafter re-renders only when triggered by events or data changes. By default, re-renders happen when a parent supplies new parameters, a cascading value changes, an event handler runs, or the component explicitly requests an update via StateHasChanged(). The framework avoids unnecessary work – for example, if none of a component’s parameters changed (for primitive or known types) or its ShouldRender() returns false, Blazor will skip a re-render. This means a component may not refresh unless its state truly changes or you manually force it. In general, you rarely need to call StateHasChanged yourself except in special scenarios, because Blazor’s conventions propagate state changes and trigger child updates automatically.

Lifecycle of a component on first render: OnInitialized/OnParametersSet run (waiting for any async tasks), then the component renders. Subsequent events also trigger re-renders as needed.

Lifecycle Methods: Blazor offers structured lifecycle callbacks on the base class ComponentBase for component initialization and after rendering. Key events include:

OnInitialized / OnInitializedAsync – called when the component is first instantiated and its initial parameters are set. Use these to kick off loading data or other setup. If OnInitializedAsync returns an incomplete task (e.g. awaiting an API call), Blazor will await it and then automatically rerender the component with the loaded data. The synchronous OnInitialized (if overridden) runs before the async one.

OnParametersSet / OnParametersSetAsync – called each time after a component’s incoming parameters have been updated (during initial render and any subsequent re-renders caused by the parent). Again, if OnParametersSetAsync is asynchronous, Blazor waits for it to finish then rerenders the component. This ensures a child can finish processing new inputs before the UI is updated.

ShouldRender – a method you can override to control whether to allow a render. By default it returns true (always render on changes), but you can return false to skip a render cycle. This is rarely overridden except for performance tuning.

OnAfterRender / OnAfterRenderAsync – called after each render is finished and the DOM is updated. The bool parameter firstRender tells you if this is the first time (useful for one-time setup like JavaScript interop calls). Important: In prerendered server-side Blazor, OnAfterRender is not called during the initial static render, only when the component becomes interactive on the client. Thus, put initialization code that requires a fully interactive DOM (e.g. JS interop) inside an if (firstRender) guard so it runs only when the client is ready.

IDisposable.OnDisposing – not a lifecycle method per se, but if a component implements IDisposable/IAsyncDisposable, Blazor calls Dispose when the component is removed. Use this to clean up timers, event handlers, or JS objects to prevent memory leaks.

Event Handling and State Updates: When a UI event occurs (button click, etc.), Blazor runs the bound event handler and then triggers a re-render on that component and any affected children. If the event handler returns a Task (i.e. is async), Blazor will await it; any state changes made mid-handler won’t show until the handler completes because the UI update is queued to run after the event logic finishes. You generally do not need to call StateHasChanged inside normal event handlers – the framework handles it. However, for long-running or multi-phase async events, you can force interim UI updates. For example, an async method performing several await steps might call StateHasChanged() between steps to refresh partial results (the first call queues a render, which executes when the method yields control). Blazor ensures that redundant calls to StateHasChanged won’t stack up extra renders – if you call it multiple times in a loop without yielding, only one re-render occurs afterwards. Avoid calling StateHasChanged more than necessary: it incurs rendering cost. Typically you use it only when state changes happen outside the normal Blazor flow (e.g. a .NET Timer or an event callback from a non-Blazor service), because those won’t automatically trigger UI updates. When using such external events, make sure to call them on the correct context – Blazor will throw if StateHasChanged is invoked from a non-UI thread without using InvokeAsync.

Render cycle summary: if not the first render and ShouldRender() returns false, Blazor skips updating the UI. Otherwise it diffs the render tree and updates the DOM, then calls OnAfterRender hooks.

Component State and Re-rendering: It’s crucial to understand that Blazor uses unidirectional data flow. Parent components pass parameters down to children, and events or callback delegates let children send information up to parents. A parent re-rendering will update its child parameters, potentially causing child re-renders. If a parent calls StateHasChanged() (or otherwise re-renders) without changing a parameter value, the child will not rerender if all its parameters are the same as last time. This is by design to prevent unnecessary work. Pitfall: Avoid writing code where a child component’s markup or behavior depends on some global variable or external state that isn’t passed in as a parameter or cascading parameter – if the parent doesn’t know that state changed, it won’t re-render the child. Always make important state part of the parameter model or call the child’s methods via event callbacks to trigger updates.

Finally, note that Blazor components render hierarchically. A parent’s output is computed first to know which child components should exist in the UI. So parent lifecycle methods run before child initialization (for synchronous code), though asynchronous init can blur the order (an async parent and async child may complete in any order). Once rendered, each component’s UI is isolated except for the data you pass – one component’s re-render doesn’t automatically refresh its siblings unless the parent causes it by changing their inputs.

Component Parameters and Data Binding

Parameter Basics: To pass data into a child component, you define a public property in the child marked with [Parameter]. The parent can then specify an attribute in the component’s tag to set that parameter. Parameters can be of any serializable type (primitives, strings, complex objects, even RenderFragments). For example, if a child component has \[Parameter] public string Title { get; set; }, a parent can include <MyChild Title="Hello"/> to pass that in. If a parent omits a parameter, the child’s property just keeps its default value (parameters can have default field initializers as seen in docs). However, do not confuse initial parameter values with ongoing state – a component should treat parameters as read-only inputs from its parent. In fact, the official guidance is never to write to your own [Parameter] properties after the first render. Overwriting parameters internally can lead to inconsistent UIs or being clobbered by the parent on the next update. The Blazor framework will simply re-assign the [Parameter] property whenever the parent re-renders, so any value the child stored there could be lost. For example, if a child has a parameter InitiallyExpanded and in its own code it does InitiallyExpanded = true when a user clicks something, that state might be overwritten when the parent updates that child (since the parent might still be passing InitiallyExpanded=false as originally). The recommended approach is: don’t mutate parameters; instead, if the component needs to change something, either raise an event to ask the parent to change the value, or use an internal property/field for tracking state changes. In scenarios where you want two-way binding (parent and child both updating a value), use the @bind- syntax which under the covers wires an event callback to propagate changes up.

Required Parameters: If a component truly cannot function without a certain parameter, you can enforce it by decorating the property with [EditorRequired] in addition to [Parameter]. This will prompt editors or build tools to warn if the parent doesn’t provide that parameter. It’s preferable to using C# required or init-only setters on components, which are not honored by the Blazor parameter binding process. For example, you might mark a Chart component’s DataSource parameter as required so that any omission is caught during development.

Child Content and RenderFragment: One special kind of parameter is RenderFragment (or RenderFragment<T>) which allows a parent to pass a chunk of UI to be rendered inside the child. This is how components can act as wrappers or templates. By convention, a component can define public RenderFragment? ChildContent { get; set; } [Parameter] to capture anything placed between its opening and closing tags. The Blazor compiler looks for a parameter exactly named ChildContent to assign the inner content. If you’re building a wrapper component (like a card that wraps arbitrary content), always include a [Parameter] RenderFragment ChildContent and then render @ChildContent in your component’s markup where appropriate. Failing to do this means any inner HTML provided by the parent will be ignored (or cause a compile error). By default, you don’t need to explicitly name the parameter when using the component; for example <MyCardComponent>Some text</MyCardComponent> will automatically pass “Some text” into the ChildContent fragment of MyCardComponent. You can also have multiple RenderFragment parameters (with different names) or generic ones for templated controls, but the usage is more advanced. Just remember: to project content, use ChildContent. Also, you cannot bind events directly to a RenderFragment parameter – events must be handled inside the fragment or passed as separate [Parameter] callbacks; the fragment is purely for UI content.

Data Binding (One-way vs Two-way): Standard usage is one-way down (parent to child). If you use @bind-Value="someField" on a child component (assuming it has a [Parameter] public T Value { get; set; } and a corresponding [Parameter] public EventCallback<T> ValueChanged { get; set; }), Blazor sets up two-way binding such that changes in the child call ValueChanged to update the parent’s someField. In PTDoc, ensure that if you generate form-like components or inputs, you follow the Blazor pattern for two-way bindable properties (Parameter + EventCallback pair named with Changed). Otherwise, the parent won’t know about updates.

Avoiding Parameter Pitfalls: To summarize safe parameter usage in guardrails for our agents:

Never have a component set its own [Parameter] property internally after initialization. Use internal state instead, or design a callback to inform the parent of needed changes. This prevents weird bugs like parent overwriting child state or infinite render loops.

If a parameter is essential, mark it with [EditorRequired] so missing assignments are caught early.

When adding a new component in a shared library or folder, remember to update _Imports.razor or add @using in consuming pages so the component’s namespace is known. Otherwise, you’ll get build warnings or it might fail to find the component (e.g. a <PTDocMetricCard> tag not recognized until you import its namespace).

Use correct casing when referencing components in markup: the first letter must be uppercase or Blazor will treat it as an HTML element and not as a component. For example, <PTDocMetricCard /> is valid if PTDocMetricCard is a component class, but <PTDocMetricCard> (lowercase) will not work and would likely just render nothing or give an error. Always name component files and classes in PascalCase (UpperCamelCase).

If your component uses cascading parameters (via [CascadingParameter] for ambient context like theme or user info), ensure that some ancestor provides a matching [CascadingValue]. Otherwise, the cascading parameter will remain at its default value. Also be cautious not to unintentionally consume cascading values by name matching – it’s better to use the Name property on CascadingParameter and CascadingValue to explicitly link them by name if you have multiple of the same type in scope.

Integration Caveats (Blazor WebAssembly vs Server, MAUI, and MVC)

Client-Side (WebAssembly) vs Server-Side Blazor: PTDoc uses Blazor in a hybrid manner – a Blazor WASM web app and a .NET MAUI app embedding Blazor. In Blazor WebAssembly, the entire app (components, rendering logic, .NET runtime) runs in the browser sandbox. This means there is no persistent server connection required for UI updates (everything is local once loaded, and data calls go through HTTP APIs). One caveat is that initial load time can be significant if the DLLs are large, so keep an eye on payload size and use ahead-of-time compile or trimming if needed for performance. Also, since state is purely in the browser, a page refresh or navigating away will reset the state unless you explicitly use browser storage or other persistence. Agents should remember to use features like PersistentComponentState (for prerendered scenarios) or saving to localStorage via JS interop if some state should survive reloads.

In Blazor Server, the components run on the server and UI updates are real-time via a SignalR connection. This has different considerations:

Each user connection (called a Circuit) holds component state in memory on the server. We must avoid using static variables for anything user-specific, as that would be shared across all users (leading to data leakage). Always use DI services with appropriate lifetimes (Scoped services are one-per-circuit in server-side) or store per-user state in CascadingParameters, not statics. In WASM, a static is fine for app-wide state (since one user = one runtime), but in Server it’s global.

If a circuit disconnects (network issue or user closes the app), any transient state in memory is gone. Recommend to handle circuit events if needed (for example, you can log or attempt to save state when a circuit is down via CircuitHandler). Also design components to be resilient – e.g., if a user reconnects, they may see a fresh component with no state unless you used PersistentComponentState to persist it across prerender and interactive phase.

Prerendering: In a Blazor Server (or Blazor Web App in .NET 8) scenario, the app often prerenders the UI as static HTML first (for faster first paint or SEO) and then establishes the interactive circuit. During prerender, components run their OnInitialized{Async} and OnParametersSet normally, but as noted, they do not run OnAfterRender until the interactive phase. Also, the framework waits for all async tasks in these lifecycle methods to complete (called quiescence) before sending the HTML to the client. This can lead to a situation where a slow operation in OnInitializedAsync will delay the entire page from rendering any UI, essentially showing a blank page while waiting. This is a known pitfall – the user might not even see a loading indicator because the component hasn’t rendered yet! To mitigate this: always show a placeholder or loading state synchronously, then perform long loads asynchronously. For example, set a flag like isLoading=true initially, start loading data in OnInitializedAsync, and in your markup show a spinner or “Loading…” message when isLoading is true. Once data is loaded (isLoading=false), Blazor will re-render and show the real content. This way, during prerender the user sees at least the loading message instead of nothing. In .NET 8, you can also use the new Streaming rendering feature: applying [StreamRendering(true)] on a component allows it to render partial output (like that loading message) immediately during prerender, and then stream the updated content later without blocking the whole page. Streaming rendering is opt-in because it can cause slight content shift when the real data appears, but it greatly improves perceived performance for slow components. PTDoc should consider using @attribute [StreamRendering] on dashboard widgets that fetch data, so the overview page isn’t blank if the network is slow.

Double initialization: One subtle effect of prerender + interactive is that certain components might run their init logic twice (once on the server, once on the client after SignalR connects). If you use [StreamRendering] or not careful, you could trigger duplicate loads (e.g., fetching the same data twice). To avoid that, .NET provides PersistentComponentState where you can stash the result from prerender and reuse it on the client so the second render doesn’t redo the work. Our internal guidelines can note: when using prerendering, guard against double-execution of expensive calls (one strategy: only load data if not already loaded, e.g. Data ??= await LoadDataAsync() as shown in docs, and consider marking data with [PersistentState] so it carries over). For PTDoc’s web app (WASM) this isn’t a concern, but if we ever prerender (or if MAUI does something similar on first load), it’s good to be aware.

.NET MAUI Integration: In the PTDoc MAUI app, Blazor is used via a BlazorWebView. This means the Blazor UI runs in a WebView component within a native app. Most of the Blazor behavior is the same as WASM (it’s essentially running a Blazor WebAssembly instance within the app). One caveat is that calling into platform features or file system may require dependency injection or JS interop with platform-specific code – ensure any such usage is abstracted (the PTDoc architecture likely separates concerns so that Blazor calls APIs provided by .NET MAUI or .NET libraries). For our purposes, agents should ensure components work in a constrained WebView environment (e.g., no assumptions about having a full browser’s capabilities like certain DOM APIs might not function in WebView sandbox, and file paths might differ). Also, do not use Window-specific JS calls (like window.alert) in a MAUI BlazorWebView – those might not behave as expected on mobile/desktop.

Using Components in Razor Pages or MVC: Although PTDoc is Blazor-centric, note that Blazor components can be embedded in traditional MVC/Razor Pages apps via the <component> tag helper. For example, one could render a Blazor component in a Razor Page with: <component type="typeof(MyComponent)" render-mode="WebAssemblyPrerendered" />. The render-mode is important – Static means just render once to HTML and that’s it (no interactivity), ServerPrerendered means include the initial HTML and bootstrap a Blazor Server connection for interactivity, WebAssemblyPrerendered means prerender and then bootstrap Blazor WASM, etc. If PTDoc were to integrate Blazor components into any non-Blazor page, ensure the correct render-mode is chosen. The docs note that statically-rendered components (no interactivity) cannot be updated or removed after rendering. So if you need a live, updating component, use one of the interactive modes. Also ensure the Blazor script is included on the page (blazor.server.js or blazor.webassembly.js as appropriate). This likely doesn’t apply to PTDoc currently, but it’s useful knowledge if in the future we embed certain components elsewhere.

Styling and Layout: Blazor uses standard CSS, and you can use either global styles or scoped CSS for components. When using scoped CSS (a .razor.css file alongside the component), Blazor will auto-scope those styles by adding unique attributes. Just remember that if a component’s elements need to be styled from outside (e.g., by a parent page’s CSS or a third-party stylesheet), scoped CSS might prevent that – you might need to turn off scoping for certain global styles or ensure consistent class names. For dashboard components like PTDocMetricCard, ensure any required CSS or icon libraries are available in both the web and MAUI host. In MAUI BlazorWebView, you might need to add the CSS files in the wwwroot of the Blazor part and confirm they are loaded.

Also, be mindful of layout components (like if using a LayoutComponent with @Body). If a new component relies on being inside a specific layout that provides context (e.g., a CascadingParameter for user theme), using it elsewhere without that layout could break it. Document any such assumptions.

Known Pitfalls Impacting Dashboards and Visibility

Loading and Async Data: As mentioned, a common pitfall for dashboard widgets is doing heavy work on first render without feedback. If the PTDocMetricCard was not showing anything, perhaps it was waiting on data with no indication. The user might see a blank space. To prevent this, always initialize visible state immediately. For example, if PTDocMetricCard loads metrics from an API, the component should at least render a placeholder card or spinner while the data loads asynchronously. This ensures the “Overview” page isn’t mysteriously empty or incomplete-looking. Agents updating such components should implement an isLoading flag or similar pattern as part of our standards.

Conditional Rendering: Another cause of invisible components can be misused conditional logic. If the wrapper component only renders its content when certain conditions are true, double-check the logic. For instance, <PTDocMetricCard>@if(data != null){ ... }</PTDocMetricCard> could render nothing if data is null. It might be better to move the if inside the component and show a loading state. Also ensure conditions are not inadvertently always false due to scoping issues (e.g., using @code variable vs a passed-in parameter incorrectly).

Parameters Not Passed: If a component expects a parameter (especially marked EditorRequired) and the parent doesn’t provide it, the component might render a default state or nothing. In an “Overview” dashboard scenario, if PTDocMetricCard needed a MetricsModel parameter and it wasn’t given, the card might have no data to display. The fix is either provide the param or have the component fetch its own data. This again points to using EditorRequired to catch such mistakes at design time. It’s a good practice we should add: Agents must mark critical input parameters with [EditorRequired] and heed any warnings about unset required params when reviewing Copilot suggestions.

Component Registration and Imports: A component that compiles and runs in one project (say the Shared RCL) but “does not render” in the app could simply be that the app didn’t know about it. In Blazor, if you add a new component to a class library, you must reference that library in the host app and usually add an @using YourLibrary.ComponentsNamespace either in each usage or globally in _Imports.razor. If PTDocMetricCard was added to PTDoc.Shared but the web project’s _Imports.razor wasn’t updated, the <PTDocMetricCard> tag in a page might be silently ignored or produce a build error (depending on whether the tooling caught it). The docs explicitly show adding @using BlazorSample.AdminComponents in _Imports.razor when using a custom folder of components. So our guardrail: whenever an agent creates a new component or moves one to a new namespace, update the relevant _Imports.razor so it’s included by default in pages. Also, adhere to the file naming conventions: if one of our components was named with a lowercase first letter, it simply will not work in Razor markup – always use PascalCase file/class names (the PTDoc codebase likely already enforces this, but it’s worth reinforcing).

Wrapper Components and Child Content: If PTDocMetricCard is a wrapper (e.g., a styled card that wraps arbitrary content or a chart), ensure that any content passed inside is being rendered. This means verifying that the component defines ChildContent and uses it. A mistake here could lead to the card appearing blank because the inner content never gets displayed. Our internal instructions should remind: when generating a wrapper, always include the standard ChildContent parameter and place @ChildContent in the markup where needed.

State Management across Components: For dashboard scenarios, multiple components might share some state (like a selected date range or patient ID). Using cascading parameters or a dedicated state container service is preferable to drilling too many parameters through. But be careful with service lifetimes: a singleton service holding UI state (like UI preferences) is fine, but if it holds per-user data in a server app, it could mix users. In PTDoc’s case, with WASM and MAUI (no multi-user server), a singleton state service is effectively per user, so that’s safe. Just note: if we ever introduce server-hosted Blazor, we’d switch such services to Scoped.

JS Interop and Visibility: If a component relies on a JS library (say a charting library) to render itself, ensure the JS is properly initialized after the component appears. Often this is done in OnAfterRenderAsync(firstRender) to activate a chart on a canvas element. If PTDocMetricCard was showing a chart and it didn’t call the JS, the card might appear empty. This ties back to OnAfterRender and prerender: in a server scenario, calling JS on firstRender (which might be prerender) would fail; you might need to wrap JS calls like: if (firstRender && JsRuntime.IsBrowser()) or simply ensure the component only rendered on the client. Agents adding JS interop should follow the pattern: call JS in OnAfterRenderAsync and ensure the script is loaded in the page (for MAUI, add to index.html or use the proper file scheme).

Layout and CSS Pitfalls: If a component is present but just not visible (0px height etc.), it could be a CSS issue (e.g., parent container with display:none or a flex container not stretching). While not directly a Blazor framework issue, our guidelines can include: After adding a new UI component, verify its CSS classes and surrounding layout to confirm it’s not inadvertently hidden. For instance, a common mistake is forgetting to add the component to the page’s grid or container. If Overview.razor had a grid and the agent forgot to place PTDocMetricCard in the markup properly, it simply wouldn’t show. Always double-check the final Razor page to see that the component tag is present in the expected location and not inside a conditional that never executes.

Updates to Copilot-Instructions.md and Agents.md (Guardrails for AI Contributions)

To prevent the kinds of issues noted above, we will add specific rules to our AI guidance files:

Additions to Copilot-Instructions.md: (for guiding GitHub Copilot code suggestions)

Component Naming & Declaration: “When Copilot suggests creating a new Blazor component, always use PascalCase for file and class names (e.g. MyComponent.razor), and ensure the class name inside matches the file. The component’s first letter must be uppercase. If adding a component in a new folder/namespace, have Copilot include an @using of that namespace in the appropriate _Imports.razor so the component is recognized by the app. (This avoids components that silently fail to render due to casing or namespace issues.)”

Parameters and Binding: “Copilot must mark input properties with [Parameter]. Do not write code that sets those properties within the component after initialization – treat them as read-only inputs. If the component needs to change something (e.g., toggle a panel open/closed), use internal state fields or two-way binding (with EventCallback). Avoid any design where a parent’s re-render would overwrite a child’s state unexpectedly. For required inputs, Copilot should use the [EditorRequired] attribute so missing parameters are caught at design time. Also, ensure any event-callback pairs follow the naming convention (e.g., Value with ValueChanged) so two-way binding can be used when appropriate.”

Wrapper Components & ChildContent: “When suggesting a ‘wrapper’ component (one that encapsulates other markup), Copilot should include a [Parameter] RenderFragment ChildContent { get; set; } property and render @ChildContent in the component’s Razor body by convention. This ensures any inner content passed by the parent will be displayed. Omit this only if the component is explicitly designed never to have inner content.”

Lifecycle and Async: “Copilot should prefer using OnInitializedAsync for startup logic that involves fetching data (with await calls). It should provide a loading indicator or placeholder in markup while async data is being fetched. For example, suggest an if (loading) ... else ... pattern, so the UI isn’t blank during load. If generating code in a server-prerendered context (or MAUI hybrid), avoid long blocking operations in lifecycle methods – instead, do minimal synchronous work and do heavy lifting asynchronously (with proper loading UI).”

StateHasChanged & UI Updates: “Copilot must not sprinkle StateHasChanged() calls unless necessary. The code suggestions should rely on Blazor’s automatic re-render on events and parameter changes. Only in cases like timer callbacks or external events (which it should rarely suggest without prompt) should it use InvokeAsync(StateHasChanged) pattern. Unnecessary calls cause performance issues.”

Error Handling & Debugging UI: “If Copilot suggests a complex UI update and something might not render, it should also suggest checking for errors in the browser console or .NET output. (This is more of a dev guidance, but we can encode it: if a component is blank, look for exceptions in console – often a null reference or similar prevented rendering.) Ensure Copilot includes null-checks where appropriate (e.g., @someObject?.Property in Razor) to avoid runtime errors that break component rendering.”

Additions to Agents.md: (for AI coding agents making direct changes)

Under the Blazor Guidelines section, we’ll insert rules like:

Blazor Component Standards: “Agents must follow Blazor component naming and usage rules: Components should be created in PascalCase and placed in the proper folder (Pages for routable pages, Shared/Components for others, unless otherwise specified). After adding a component, update _Imports.razor or relevant files to include its namespace. Verify that the component appears in the UI by running the app if possible.”

Ensure Component Visibility: “Before concluding a UI change, the agent should verify that new components actually render content. For example, if adding PTDocMetricCard to Overview.razor, ensure it’s not inside a never-true conditional and that any data it needs is provided. Agents should add fallback content (like “No data” or loading spinners) so that a component isn’t empty while waiting for inputs.”

Lifecycle Usage: “Agents must utilize Blazor lifecycle methods appropriately. Use OnInitializedAsync for async setup (and avoid long work in synchronous OnInitialized). If using OnAfterRenderAsync, check the firstRender flag to run one-time setup (like JavaScript interop) to avoid repeat execution. Do not call OnAfterRender code during prerender that assumes interactivity – guard it or delay it until connected (especially important for MAUI and future server-side usage).”

No Parameter Self-Overwrite: “Agents are forbidden from writing code that sets a [Parameter] property inside the component after first render. This can cause parent-child synchronization bugs. Instead, if a component needs to change due to user action, either emit an EventCallback to inform the parent or use an internal private field. For example, do not do ParameterX = newValue in the child; that should be handled via binding or parent logic.”

Dashboard Specific: “When modifying dashboard cards or metrics components, agents must ensure that each component handles loading states and error states. Provide user feedback for slow data (e.g., a <em>Loading...</em> text). Also, components that depend on context (like selected patient or date range) should use cascading parameters or parameters from the parent – the agent should not introduce hidden dependencies. Document in the component’s code comments what it expects (to ease future integration).”

Testing Interactive Behavior: “Agents should add or update unit tests for critical components if possible (though UI logic can be tricky to unit test, consider using bUnit for Blazor components). At minimum, manually verify that after an agent’s changes, the component appears and updates as expected in both the Blazor Web app and the MAUI app. For instance, after fixing PTDocMetricCard, ensure it shows up on the Overview page with real data and responds to any user interaction.”

By encoding the above in our Copilot and Agents instructions, we create a safety net. The AI assistant will be guided to produce Blazor components that correctly declare parameters, manage state, and integrate without the common pitfalls that break rendering. In summary, the overarching rules for any AI-generated Blazor code in PTDoc are: respect the Blazor component model (proper parameters, lifecycle, naming), don’t break the render flow (no self-parameter writes, unnecessary StateHasChanged, etc.), and always account for loading and integration context to avoid invisible or non-functional UI. Following the official .NET 8 Blazor guidance on these points will prevent issues like the missing PTDocMetricCard and improve overall stability of the PTDoc application.

Sources:

Microsoft Docs – ASP.NET Core Razor components (Blazor fundamentals on components, parameters, naming)

Microsoft Docs – Razor component lifecycle and rendering (lifecycle events, rendering triggers, StateHasChanged usage)

Microsoft Docs – Avoid overwriting parameters in Blazor (why components should not write to their own parameters)

Microsoft Docs – Blazor asynchronous rendering and loading states (quiescence, streaming rendering, placeholders during async tasks)

PTDoc Agents Guide – Agents.md (project-specific standards to be extended with Blazor rules)